\hypertarget{gtest-printers_8h_source}{}\doxysection{gtest-\/printers.h}
\label{gtest-printers_8h_source}\index{D:/vs\_project/Summer\_school/packages/Microsoft.googletest.v140.windesktop.msvcstl.static.rt-\/dyn.1.8.1.4/build/native/include/gtest/gtest-\/printers.h@{D:/vs\_project/Summer\_school/packages/Microsoft.googletest.v140.windesktop.msvcstl.static.rt-\/dyn.1.8.1.4/build/native/include/gtest/gtest-\/printers.h}}
\mbox{\hyperlink{gtest-printers_8h}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2007, Google Inc.}}
\DoxyCodeLine{2 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// Redistribution and use in source and binary forms, with or without}}
\DoxyCodeLine{5 \textcolor{comment}{// modification, are permitted provided that the following conditions are}}
\DoxyCodeLine{6 \textcolor{comment}{// met:}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{//     * Redistributions of source code must retain the above copyright}}
\DoxyCodeLine{9 \textcolor{comment}{// notice, this list of conditions and the following disclaimer.}}
\DoxyCodeLine{10 \textcolor{comment}{//     * Redistributions in binary form must reproduce the above}}
\DoxyCodeLine{11 \textcolor{comment}{// copyright notice, this list of conditions and the following disclaimer}}
\DoxyCodeLine{12 \textcolor{comment}{// in the documentation and/or other materials provided with the}}
\DoxyCodeLine{13 \textcolor{comment}{// distribution.}}
\DoxyCodeLine{14 \textcolor{comment}{//     * Neither the name of Google Inc. nor the names of its}}
\DoxyCodeLine{15 \textcolor{comment}{// contributors may be used to endorse or promote products derived from}}
\DoxyCodeLine{16 \textcolor{comment}{// this software without specific prior written permission.}}
\DoxyCodeLine{17 \textcolor{comment}{//}}
\DoxyCodeLine{18 \textcolor{comment}{// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}}
\DoxyCodeLine{19 \textcolor{comment}{// "{}AS IS"{} AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}}
\DoxyCodeLine{20 \textcolor{comment}{// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}}
\DoxyCodeLine{21 \textcolor{comment}{// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}}
\DoxyCodeLine{22 \textcolor{comment}{// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}}
\DoxyCodeLine{23 \textcolor{comment}{// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}}
\DoxyCodeLine{24 \textcolor{comment}{// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}}
\DoxyCodeLine{25 \textcolor{comment}{// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}}
\DoxyCodeLine{26 \textcolor{comment}{// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}}
\DoxyCodeLine{27 \textcolor{comment}{// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}}
\DoxyCodeLine{28 \textcolor{comment}{// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 }
\DoxyCodeLine{31 \textcolor{comment}{// Google Test -\/ The Google C++ Testing and Mocking Framework}}
\DoxyCodeLine{32 \textcolor{comment}{//}}
\DoxyCodeLine{33 \textcolor{comment}{// This file implements a universal value printer that can print a}}
\DoxyCodeLine{34 \textcolor{comment}{// value of any type T:}}
\DoxyCodeLine{35 \textcolor{comment}{//}}
\DoxyCodeLine{36 \textcolor{comment}{//   void ::testing::internal::UniversalPrinter<T>::Print(value, ostream\_ptr);}}
\DoxyCodeLine{37 \textcolor{comment}{//}}
\DoxyCodeLine{38 \textcolor{comment}{// A user can teach this function how to print a class type T by}}
\DoxyCodeLine{39 \textcolor{comment}{// defining either operator<<() or PrintTo() in the namespace that}}
\DoxyCodeLine{40 \textcolor{comment}{// defines T.  More specifically, the FIRST defined function in the}}
\DoxyCodeLine{41 \textcolor{comment}{// following list will be used (assuming T is defined in namespace}}
\DoxyCodeLine{42 \textcolor{comment}{// foo):}}
\DoxyCodeLine{43 \textcolor{comment}{//}}
\DoxyCodeLine{44 \textcolor{comment}{//   1. foo::PrintTo(const T\&, ostream*)}}
\DoxyCodeLine{45 \textcolor{comment}{//   2. operator<<(ostream\&, const T\&) defined in either foo or the}}
\DoxyCodeLine{46 \textcolor{comment}{//      global namespace.}}
\DoxyCodeLine{47 \textcolor{comment}{//}}
\DoxyCodeLine{48 \textcolor{comment}{// However if T is an STL-\/style container then it is printed element-\/wise}}
\DoxyCodeLine{49 \textcolor{comment}{// unless foo::PrintTo(const T\&, ostream*) is defined. Note that}}
\DoxyCodeLine{50 \textcolor{comment}{// operator<<() is ignored for container types.}}
\DoxyCodeLine{51 \textcolor{comment}{//}}
\DoxyCodeLine{52 \textcolor{comment}{// If none of the above is defined, it will print the debug string of}}
\DoxyCodeLine{53 \textcolor{comment}{// the value if it is a protocol buffer, or print the raw bytes in the}}
\DoxyCodeLine{54 \textcolor{comment}{// value otherwise.}}
\DoxyCodeLine{55 \textcolor{comment}{//}}
\DoxyCodeLine{56 \textcolor{comment}{// To aid debugging: when T is a reference type, the address of the}}
\DoxyCodeLine{57 \textcolor{comment}{// value is also printed; when T is a (const) char pointer, both the}}
\DoxyCodeLine{58 \textcolor{comment}{// pointer value and the NUL-\/terminated string it points to are}}
\DoxyCodeLine{59 \textcolor{comment}{// printed.}}
\DoxyCodeLine{60 \textcolor{comment}{//}}
\DoxyCodeLine{61 \textcolor{comment}{// We also provide some convenient wrappers:}}
\DoxyCodeLine{62 \textcolor{comment}{//}}
\DoxyCodeLine{63 \textcolor{comment}{//   // Prints a value to a string.  For a (const or not) char}}
\DoxyCodeLine{64 \textcolor{comment}{//   // pointer, the NUL-\/terminated string (but not the pointer) is}}
\DoxyCodeLine{65 \textcolor{comment}{//   // printed.}}
\DoxyCodeLine{66 \textcolor{comment}{//   std::string ::testing::PrintToString(const T\& value);}}
\DoxyCodeLine{67 \textcolor{comment}{//}}
\DoxyCodeLine{68 \textcolor{comment}{//   // Prints a value tersely: for a reference type, the referenced}}
\DoxyCodeLine{69 \textcolor{comment}{//   // value (but not the address) is printed; for a (const or not) char}}
\DoxyCodeLine{70 \textcolor{comment}{//   // pointer, the NUL-\/terminated string (but not the pointer) is}}
\DoxyCodeLine{71 \textcolor{comment}{//   // printed.}}
\DoxyCodeLine{72 \textcolor{comment}{//   void ::testing::internal::UniversalTersePrint(const T\& value, ostream*);}}
\DoxyCodeLine{73 \textcolor{comment}{//}}
\DoxyCodeLine{74 \textcolor{comment}{//   // Prints value using the type inferred by the compiler.  The difference}}
\DoxyCodeLine{75 \textcolor{comment}{//   // from UniversalTersePrint() is that this function prints both the}}
\DoxyCodeLine{76 \textcolor{comment}{//   // pointer and the NUL-\/terminated string for a (const or not) char pointer.}}
\DoxyCodeLine{77 \textcolor{comment}{//   void ::testing::internal::UniversalPrint(const T\& value, ostream*);}}
\DoxyCodeLine{78 \textcolor{comment}{//}}
\DoxyCodeLine{79 \textcolor{comment}{//   // Prints the fields of a tuple tersely to a string vector, one}}
\DoxyCodeLine{80 \textcolor{comment}{//   // element for each field. Tuple support must be enabled in}}
\DoxyCodeLine{81 \textcolor{comment}{//   // gtest-\/port.h.}}
\DoxyCodeLine{82 \textcolor{comment}{//   std::vector<string> UniversalTersePrintTupleFieldsToStrings(}}
\DoxyCodeLine{83 \textcolor{comment}{//       const Tuple\& value);}}
\DoxyCodeLine{84 \textcolor{comment}{//}}
\DoxyCodeLine{85 \textcolor{comment}{// Known limitation:}}
\DoxyCodeLine{86 \textcolor{comment}{//}}
\DoxyCodeLine{87 \textcolor{comment}{// The print primitives print the elements of an STL-\/style container}}
\DoxyCodeLine{88 \textcolor{comment}{// using the compiler-\/inferred type of *iter where iter is a}}
\DoxyCodeLine{89 \textcolor{comment}{// const\_iterator of the container.  When const\_iterator is an input}}
\DoxyCodeLine{90 \textcolor{comment}{// iterator but not a forward iterator, this inferred type may not}}
\DoxyCodeLine{91 \textcolor{comment}{// match value\_type, and the print output may be incorrect.  In}}
\DoxyCodeLine{92 \textcolor{comment}{// practice, this is rarely a problem as for most containers}}
\DoxyCodeLine{93 \textcolor{comment}{// const\_iterator is a forward iterator.  We'll fix this if there's an}}
\DoxyCodeLine{94 \textcolor{comment}{// actual need for it.  Note that this fix cannot rely on value\_type}}
\DoxyCodeLine{95 \textcolor{comment}{// being defined as many user-\/defined container types don't have}}
\DoxyCodeLine{96 \textcolor{comment}{// value\_type.}}
\DoxyCodeLine{97 }
\DoxyCodeLine{98 \textcolor{comment}{// GOOGLETEST\_CM0001 DO NOT DELETE}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100 \textcolor{preprocessor}{\#ifndef GTEST\_INCLUDE\_GTEST\_GTEST\_PRINTERS\_H\_}}
\DoxyCodeLine{101 \textcolor{preprocessor}{\#define GTEST\_INCLUDE\_GTEST\_GTEST\_PRINTERS\_H\_}}
\DoxyCodeLine{102 }
\DoxyCodeLine{103 \textcolor{preprocessor}{\#include <ostream>}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{104 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{105 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{106 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{107 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{108 \textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{gtest-port_8h}{gtest/internal/gtest-\/port.h}}"{}}}
\DoxyCodeLine{109 \textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{gtest-internal_8h}{gtest/internal/gtest-\/internal.h}}"{}}}
\DoxyCodeLine{110 }
\DoxyCodeLine{111 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_TUPLE\_}}
\DoxyCodeLine{112 \textcolor{preprocessor}{\# include <tuple>}}
\DoxyCodeLine{113 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{114 }
\DoxyCodeLine{115 \textcolor{preprocessor}{\#if GTEST\_HAS\_ABSL}}
\DoxyCodeLine{116 \textcolor{preprocessor}{\#include "{}absl/strings/string\_view.h"{}}}
\DoxyCodeLine{117 \textcolor{preprocessor}{\#include "{}absl/types/optional.h"{}}}
\DoxyCodeLine{118 \textcolor{preprocessor}{\#include "{}absl/types/variant.h"{}}}
\DoxyCodeLine{119 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_ABSL}}
\DoxyCodeLine{120 }
\DoxyCodeLine{121 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacetesting}{testing}} \{}
\DoxyCodeLine{122 }
\DoxyCodeLine{123 \textcolor{comment}{// Definitions in the 'internal' and 'internal2' name spaces are}}
\DoxyCodeLine{124 \textcolor{comment}{// subject to change without notice.  DO NOT USE THEM IN USER CODE!}}
\DoxyCodeLine{125 \textcolor{keyword}{namespace }internal2 \{}
\DoxyCodeLine{126 }
\DoxyCodeLine{127 \textcolor{comment}{// Prints the given number of bytes in the given object to the given}}
\DoxyCodeLine{128 \textcolor{comment}{// ostream.}}
\DoxyCodeLine{129 \mbox{\hyperlink{gtest-port_8h_aa73be6f0ba4a7456180a94904ce17790}{GTEST\_API\_}} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal2_a9fbf8e07c0f94dc74d6ef5e56cd3c553}{PrintBytesInObjectTo}}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* obj\_bytes,}
\DoxyCodeLine{130                                      \textcolor{keywordtype}{size\_t} count,}
\DoxyCodeLine{131                                      ::std::ostream* os);}
\DoxyCodeLine{132 }
\DoxyCodeLine{133 \textcolor{comment}{// For selecting which printer to use when a given type has neither <<}}
\DoxyCodeLine{134 \textcolor{comment}{// nor PrintTo().}}
\DoxyCodeLine{135 \textcolor{keyword}{enum} \mbox{\hyperlink{namespacetesting_1_1internal2_aeb8161b0b3ee503347b0662d7028fd57}{TypeKind}} \{}
\DoxyCodeLine{136   \mbox{\hyperlink{namespacetesting_1_1internal2_aeb8161b0b3ee503347b0662d7028fd57a14aaf98a2547ecf43eef0868d54b1383}{kProtobuf}},              \textcolor{comment}{// a protobuf type}}
\DoxyCodeLine{137   \mbox{\hyperlink{namespacetesting_1_1internal2_aeb8161b0b3ee503347b0662d7028fd57a9bdcf3f1548f498b2b7f097306ea0224}{kConvertibleToInteger}},  \textcolor{comment}{// a type implicitly convertible to BiggestInt}}
\DoxyCodeLine{138                           \textcolor{comment}{// (e.g. a named or unnamed enum type)}}
\DoxyCodeLine{139 \textcolor{preprocessor}{\#if GTEST\_HAS\_ABSL}}
\DoxyCodeLine{140   kConvertibleToStringView,  \textcolor{comment}{// a type implicitly convertible to}}
\DoxyCodeLine{141                              \textcolor{comment}{// absl::string\_view}}
\DoxyCodeLine{142 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{143   \mbox{\hyperlink{namespacetesting_1_1internal2_aeb8161b0b3ee503347b0662d7028fd57abe8aaea44751d6ebd0cdf5bd94451db1}{kOtherType}}  \textcolor{comment}{// anything else}}
\DoxyCodeLine{144 \};}
\DoxyCodeLine{145 }
\DoxyCodeLine{146 \textcolor{comment}{// TypeWithoutFormatter<T, kTypeKind>::PrintValue(value, os) is called}}
\DoxyCodeLine{147 \textcolor{comment}{// by the universal printer to print a value of type T when neither}}
\DoxyCodeLine{148 \textcolor{comment}{// operator<< nor PrintTo() is defined for T, where kTypeKind is the}}
\DoxyCodeLine{149 \textcolor{comment}{// "{}kind"{} of T as defined by enum TypeKind.}}
\DoxyCodeLine{150 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, TypeKind kTypeKind>}
\DoxyCodeLine{151 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal2_1_1_type_without_formatter}{TypeWithoutFormatter}} \{}
\DoxyCodeLine{152  \textcolor{keyword}{public}:}
\DoxyCodeLine{153   \textcolor{comment}{// This default version is called when kTypeKind is kOtherType.}}
\DoxyCodeLine{154   \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal2_1_1_type_without_formatter_a6651f6f7be2c0f899729eeb6038f76d3}{PrintValue}}(\textcolor{keyword}{const} T\& value, ::std::ostream* os) \{}
\DoxyCodeLine{155     \mbox{\hyperlink{namespacetesting_1_1internal2_a9fbf8e07c0f94dc74d6ef5e56cd3c553}{PrintBytesInObjectTo}}(\textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*\textcolor{keyword}{>}(}
\DoxyCodeLine{156                              \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&value)),}
\DoxyCodeLine{157                          \textcolor{keyword}{sizeof}(value), os);}
\DoxyCodeLine{158   \}}
\DoxyCodeLine{159 \};}
\DoxyCodeLine{160 }
\DoxyCodeLine{161 \textcolor{comment}{// We print a protobuf using its ShortDebugString() when the string}}
\DoxyCodeLine{162 \textcolor{comment}{// doesn't exceed this many characters; otherwise we print it using}}
\DoxyCodeLine{163 \textcolor{comment}{// DebugString() for better readability.}}
\DoxyCodeLine{164 \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} \mbox{\hyperlink{namespacetesting_1_1internal2_a140c8efd51e63a3def98445bff107518}{kProtobufOneLinerMaxLength}} = 50;}
\DoxyCodeLine{165 }
\DoxyCodeLine{166 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{167 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal2_1_1_type_without_formatter}{TypeWithoutFormatter}}<T, \mbox{\hyperlink{namespacetesting_1_1internal2_aeb8161b0b3ee503347b0662d7028fd57a14aaf98a2547ecf43eef0868d54b1383}{kProtobuf}}> \{}
\DoxyCodeLine{168  \textcolor{keyword}{public}:}
\DoxyCodeLine{169   \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal2_1_1_type_without_formatter_3_01_t_00_01k_protobuf_01_4_ac96fb775dc776f02da9a671ea0e04599}{PrintValue}}(\textcolor{keyword}{const} T\& value, ::std::ostream* os) \{}
\DoxyCodeLine{170     \mbox{\hyperlink{namespacetesting_1_1internal_a5ca8a348395a6145775c1a2334e21889}{std::string}} pretty\_str = value.ShortDebugString();}
\DoxyCodeLine{171     \textcolor{keywordflow}{if} (pretty\_str.length() > \mbox{\hyperlink{namespacetesting_1_1internal2_a140c8efd51e63a3def98445bff107518}{kProtobufOneLinerMaxLength}}) \{}
\DoxyCodeLine{172       pretty\_str = \textcolor{stringliteral}{"{}\(\backslash\)n"{}} + value.DebugString();}
\DoxyCodeLine{173     \}}
\DoxyCodeLine{174     *os << (\textcolor{stringliteral}{"{}<"{}} + pretty\_str + \textcolor{stringliteral}{"{}>"{}});}
\DoxyCodeLine{175   \}}
\DoxyCodeLine{176 \};}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{179 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal2_1_1_type_without_formatter}{TypeWithoutFormatter}}<T, \mbox{\hyperlink{namespacetesting_1_1internal2_aeb8161b0b3ee503347b0662d7028fd57a9bdcf3f1548f498b2b7f097306ea0224}{kConvertibleToInteger}}> \{}
\DoxyCodeLine{180  \textcolor{keyword}{public}:}
\DoxyCodeLine{181   \textcolor{comment}{// Since T has no << operator or PrintTo() but can be implicitly}}
\DoxyCodeLine{182   \textcolor{comment}{// converted to BiggestInt, we print it as a BiggestInt.}}
\DoxyCodeLine{183   \textcolor{comment}{//}}
\DoxyCodeLine{184   \textcolor{comment}{// Most likely T is an enum type (either named or unnamed), in which}}
\DoxyCodeLine{185   \textcolor{comment}{// case printing it as an integer is the desired behavior.  In case}}
\DoxyCodeLine{186   \textcolor{comment}{// T is not an enum, printing it as an integer is the best we can do}}
\DoxyCodeLine{187   \textcolor{comment}{// given that it has no user-\/defined printer.}}
\DoxyCodeLine{188   \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal2_1_1_type_without_formatter_3_01_t_00_01k_convertible_to_integer_01_4_ab27a411afb608e730a57d232b3f4f486}{PrintValue}}(\textcolor{keyword}{const} T\& value, ::std::ostream* os) \{}
\DoxyCodeLine{189     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetesting_1_1internal_a05c6bd9ede5ccdf25191a590d610dcc6}{internal::BiggestInt}} kBigInt = value;}
\DoxyCodeLine{190     *os << kBigInt;}
\DoxyCodeLine{191   \}}
\DoxyCodeLine{192 \};}
\DoxyCodeLine{193 }
\DoxyCodeLine{194 \textcolor{preprocessor}{\#if GTEST\_HAS\_ABSL}}
\DoxyCodeLine{195 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{196 \textcolor{keyword}{class }TypeWithoutFormatter<T, kConvertibleToStringView> \{}
\DoxyCodeLine{197  \textcolor{keyword}{public}:}
\DoxyCodeLine{198   \textcolor{comment}{// Since T has neither operator<< nor PrintTo() but can be implicitly}}
\DoxyCodeLine{199   \textcolor{comment}{// converted to absl::string\_view, we print it as a absl::string\_view.}}
\DoxyCodeLine{200   \textcolor{comment}{//}}
\DoxyCodeLine{201   \textcolor{comment}{// Note: the implementation is further below, as it depends on}}
\DoxyCodeLine{202   \textcolor{comment}{// internal::PrintTo symbol which is defined later in the file.}}
\DoxyCodeLine{203   \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal2_1_1_type_without_formatter_a6651f6f7be2c0f899729eeb6038f76d3}{PrintValue}}(\textcolor{keyword}{const} T\& value, ::std::ostream* os);}
\DoxyCodeLine{204 \};}
\DoxyCodeLine{205 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{206 }
\DoxyCodeLine{207 \textcolor{comment}{// Prints the given value to the given ostream.  If the value is a}}
\DoxyCodeLine{208 \textcolor{comment}{// protocol message, its debug string is printed; if it's an enum or}}
\DoxyCodeLine{209 \textcolor{comment}{// of a type implicitly convertible to BiggestInt, it's printed as an}}
\DoxyCodeLine{210 \textcolor{comment}{// integer; otherwise the bytes in the value are printed.  This is}}
\DoxyCodeLine{211 \textcolor{comment}{// what UniversalPrinter<T>::Print() does when it knows nothing about}}
\DoxyCodeLine{212 \textcolor{comment}{// type T and T has neither << operator nor PrintTo().}}
\DoxyCodeLine{213 \textcolor{comment}{//}}
\DoxyCodeLine{214 \textcolor{comment}{// A user can override this behavior for a class type Foo by defining}}
\DoxyCodeLine{215 \textcolor{comment}{// a << operator in the namespace where Foo is defined.}}
\DoxyCodeLine{216 \textcolor{comment}{//}}
\DoxyCodeLine{217 \textcolor{comment}{// We put this operator in namespace 'internal2' instead of 'internal'}}
\DoxyCodeLine{218 \textcolor{comment}{// to simplify the implementation, as much code in 'internal' needs to}}
\DoxyCodeLine{219 \textcolor{comment}{// use << in STL, which would conflict with our own << were it defined}}
\DoxyCodeLine{220 \textcolor{comment}{// in 'internal'.}}
\DoxyCodeLine{221 \textcolor{comment}{//}}
\DoxyCodeLine{222 \textcolor{comment}{// Note that this operator<< takes a generic std::basic\_ostream<Char,}}
\DoxyCodeLine{223 \textcolor{comment}{// CharTraits> type instead of the more restricted std::ostream.  If}}
\DoxyCodeLine{224 \textcolor{comment}{// we define it to take an std::ostream instead, we'll get an}}
\DoxyCodeLine{225 \textcolor{comment}{// "{}ambiguous overloads"{} compiler error when trying to print a type}}
\DoxyCodeLine{226 \textcolor{comment}{// Foo that supports streaming to std::basic\_ostream<Char,}}
\DoxyCodeLine{227 \textcolor{comment}{// CharTraits>, as the compiler cannot tell whether}}
\DoxyCodeLine{228 \textcolor{comment}{// operator<<(std::ostream\&, const T\&) or}}
\DoxyCodeLine{229 \textcolor{comment}{// operator<<(std::basic\_stream<Char, CharTraits>, const Foo\&) is more}}
\DoxyCodeLine{230 \textcolor{comment}{// specific.}}
\DoxyCodeLine{231 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} CharTraits, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{232 ::std::basic\_ostream<Char, CharTraits>\& \mbox{\hyperlink{namespacetesting_1_1internal2_aabfdaa0c4719ce3bf82964d0fcf8d999}{operator<<}}(}
\DoxyCodeLine{233     ::std::basic\_ostream<Char, CharTraits>\& os, \textcolor{keyword}{const} T\& x) \{}
\DoxyCodeLine{234   TypeWithoutFormatter<T, (\mbox{\hyperlink{structtesting_1_1internal_1_1bool__constant_a499fba6576296b04d99690a486424b32}{internal::IsAProtocolMessage<T>::value}}}
\DoxyCodeLine{235                                ? \mbox{\hyperlink{namespacetesting_1_1internal2_aeb8161b0b3ee503347b0662d7028fd57a14aaf98a2547ecf43eef0868d54b1383}{kProtobuf}}}
\DoxyCodeLine{236                                : internal::ImplicitlyConvertible<}
\DoxyCodeLine{237                                      \textcolor{keyword}{const} T\&, \mbox{\hyperlink{namespacetesting_1_1internal_a05c6bd9ede5ccdf25191a590d610dcc6}{internal::BiggestInt}}>::value}
\DoxyCodeLine{238                                      ? \mbox{\hyperlink{namespacetesting_1_1internal2_aeb8161b0b3ee503347b0662d7028fd57a9bdcf3f1548f498b2b7f097306ea0224}{kConvertibleToInteger}}}
\DoxyCodeLine{239                                      :}
\DoxyCodeLine{240 \textcolor{preprocessor}{\#if GTEST\_HAS\_ABSL}}
\DoxyCodeLine{241                                      internal::ImplicitlyConvertible<}
\DoxyCodeLine{242                                          \textcolor{keyword}{const} T\&, absl::string\_view>::value}
\DoxyCodeLine{243                                          ? kConvertibleToStringView}
\DoxyCodeLine{244                                          :}
\DoxyCodeLine{245 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{246                                          \mbox{\hyperlink{namespacetesting_1_1internal2_aeb8161b0b3ee503347b0662d7028fd57abe8aaea44751d6ebd0cdf5bd94451db1}{kOtherType}})>::PrintValue(x, \&os);}
\DoxyCodeLine{247   \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{248 \}}
\DoxyCodeLine{249 }
\DoxyCodeLine{250 \}  \textcolor{comment}{// namespace internal2}}
\DoxyCodeLine{251 \}  \textcolor{comment}{// namespace testing}}
\DoxyCodeLine{252 }
\DoxyCodeLine{253 \textcolor{comment}{// This namespace MUST NOT BE NESTED IN ::testing, or the name look-\/up}}
\DoxyCodeLine{254 \textcolor{comment}{// magic needed for implementing UniversalPrinter won't work.}}
\DoxyCodeLine{255 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacetesting__internal}{testing\_internal}} \{}
\DoxyCodeLine{256 }
\DoxyCodeLine{257 \textcolor{comment}{// Used to print a value that is not an STL-\/style container when the}}
\DoxyCodeLine{258 \textcolor{comment}{// user doesn't define PrintTo() for it.}}
\DoxyCodeLine{259 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{260 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting__internal_a3f49d3d0c996242f9d383c850097a656}{DefaultPrintNonContainerTo}}(\textcolor{keyword}{const} T\& value, ::std::ostream* os) \{}
\DoxyCodeLine{261   \textcolor{comment}{// With the following statement, during unqualified name lookup,}}
\DoxyCodeLine{262   \textcolor{comment}{// testing::internal2::operator<< appears as if it was declared in}}
\DoxyCodeLine{263   \textcolor{comment}{// the nearest enclosing namespace that contains both}}
\DoxyCodeLine{264   \textcolor{comment}{// ::testing\_internal and ::testing::internal2, i.e. the global}}
\DoxyCodeLine{265   \textcolor{comment}{// namespace.  For more details, refer to the C++ Standard section}}
\DoxyCodeLine{266   \textcolor{comment}{// 7.3.4-\/1 [namespace.udir].  This allows us to fall back onto}}
\DoxyCodeLine{267   \textcolor{comment}{// testing::internal2::operator<< in case T doesn't come with a <<}}
\DoxyCodeLine{268   \textcolor{comment}{// operator.}}
\DoxyCodeLine{269   \textcolor{comment}{//}}
\DoxyCodeLine{270   \textcolor{comment}{// We cannot write 'using ::testing::internal2::operator<<;', which}}
\DoxyCodeLine{271   \textcolor{comment}{// gcc 3.3 fails to compile due to a compiler bug.}}
\DoxyCodeLine{272   \textcolor{keyword}{using namespace }::\mbox{\hyperlink{namespacetesting_1_1internal2}{testing::internal2}};  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{273 }
\DoxyCodeLine{274   \textcolor{comment}{// Assuming T is defined in namespace foo, in the next statement,}}
\DoxyCodeLine{275   \textcolor{comment}{// the compiler will consider all of:}}
\DoxyCodeLine{276   \textcolor{comment}{//}}
\DoxyCodeLine{277   \textcolor{comment}{//   1. foo::operator<< (thanks to Koenig look-\/up),}}
\DoxyCodeLine{278   \textcolor{comment}{//   2. ::operator<< (as the current namespace is enclosed in ::),}}
\DoxyCodeLine{279   \textcolor{comment}{//   3. testing::internal2::operator<< (thanks to the using statement above).}}
\DoxyCodeLine{280   \textcolor{comment}{//}}
\DoxyCodeLine{281   \textcolor{comment}{// The operator<< whose type matches T best will be picked.}}
\DoxyCodeLine{282   \textcolor{comment}{//}}
\DoxyCodeLine{283   \textcolor{comment}{// We deliberately allow \#2 to be a candidate, as sometimes it's}}
\DoxyCodeLine{284   \textcolor{comment}{// impossible to define \#1 (e.g. when foo is ::std, defining}}
\DoxyCodeLine{285   \textcolor{comment}{// anything in it is undefined behavior unless you are a compiler}}
\DoxyCodeLine{286   \textcolor{comment}{// vendor.).}}
\DoxyCodeLine{287   *os << value;}
\DoxyCodeLine{288 \}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 \}  \textcolor{comment}{// namespace testing\_internal}}
\DoxyCodeLine{291 }
\DoxyCodeLine{292 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacetesting}{testing}} \{}
\DoxyCodeLine{293 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{294 }
\DoxyCodeLine{295 \textcolor{comment}{// FormatForComparison<ToPrint, OtherOperand>::Format(value) formats a}}
\DoxyCodeLine{296 \textcolor{comment}{// value of type ToPrint that is an operand of a comparison assertion}}
\DoxyCodeLine{297 \textcolor{comment}{// (e.g. ASSERT\_EQ).  OtherOperand is the type of the other operand in}}
\DoxyCodeLine{298 \textcolor{comment}{// the comparison, and is used to help determine the best way to}}
\DoxyCodeLine{299 \textcolor{comment}{// format the value.  In particular, when the value is a C string}}
\DoxyCodeLine{300 \textcolor{comment}{// (char pointer) and the other operand is an STL string object, we}}
\DoxyCodeLine{301 \textcolor{comment}{// want to format the C string as a string, since we know it is}}
\DoxyCodeLine{302 \textcolor{comment}{// compared by value with the string object.  If the value is a char}}
\DoxyCodeLine{303 \textcolor{comment}{// pointer but the other operand is not an STL string object, we don't}}
\DoxyCodeLine{304 \textcolor{comment}{// know whether the pointer is supposed to point to a NUL-\/terminated}}
\DoxyCodeLine{305 \textcolor{comment}{// string, and thus want to print it as a pointer to be safe.}}
\DoxyCodeLine{306 \textcolor{comment}{//}}
\DoxyCodeLine{307 \textcolor{comment}{// INTERNAL IMPLEMENTATION -\/ DO NOT USE IN A USER PROGRAM.}}
\DoxyCodeLine{308 }
\DoxyCodeLine{309 \textcolor{comment}{// The default case.}}
\DoxyCodeLine{310 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ToPr\textcolor{keywordtype}{int}, \textcolor{keyword}{typename} OtherOperand>}
\DoxyCodeLine{311 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1_format_for_comparison}{FormatForComparison}} \{}
\DoxyCodeLine{312  \textcolor{keyword}{public}:}
\DoxyCodeLine{313   \mbox{\hyperlink{namespacetesting_1_1internal_a5ca8a348395a6145775c1a2334e21889}{static ::std::string}} \mbox{\hyperlink{classtesting_1_1internal_1_1_format_for_comparison_a2aeb688fc55b57abd3021d82eccad896}{Format}}(\textcolor{keyword}{const} ToPrint\& value) \{}
\DoxyCodeLine{314     \mbox{\hyperlink{namespacetesting_aa5717bb1144edd1d262d310ba70c82ed}{return ::testing::PrintToString}}(value);}
\DoxyCodeLine{315   \}}
\DoxyCodeLine{316 \};}
\DoxyCodeLine{317 }
\DoxyCodeLine{318 \textcolor{comment}{// Array.}}
\DoxyCodeLine{319 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ToPr\textcolor{keywordtype}{int}, \textcolor{keywordtype}{size\_t} N, \textcolor{keyword}{typename} OtherOperand>}
\DoxyCodeLine{320 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1_format_for_comparison}{FormatForComparison}}<ToPrint[N], OtherOperand> \{}
\DoxyCodeLine{321  \textcolor{keyword}{public}:}
\DoxyCodeLine{322   \mbox{\hyperlink{namespacetesting_1_1internal_a5ca8a348395a6145775c1a2334e21889}{static ::std::string}} \mbox{\hyperlink{classtesting_1_1internal_1_1_format_for_comparison_3_01_to_print_0f_n_0e_00_01_other_operand_01_4_a76c526461c8fa7df75f7b32ab889b9e0}{Format}}(\textcolor{keyword}{const} ToPrint* value) \{}
\DoxyCodeLine{323     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1_format_for_comparison_a2aeb688fc55b57abd3021d82eccad896}{FormatForComparison<const ToPrint*, OtherOperand>::Format}}(value);}
\DoxyCodeLine{324   \}}
\DoxyCodeLine{325 \};}
\DoxyCodeLine{326 }
\DoxyCodeLine{327 \textcolor{comment}{// By default, print C string as pointers to be safe, as we don't know}}
\DoxyCodeLine{328 \textcolor{comment}{// whether they actually point to a NUL-\/terminated string.}}
\DoxyCodeLine{329 }
\DoxyCodeLine{330 \textcolor{preprocessor}{\#define GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_POINTER\_(CharType)                \(\backslash\)}}
\DoxyCodeLine{331 \textcolor{preprocessor}{  template <typename OtherOperand>                                      \(\backslash\)}}
\DoxyCodeLine{332 \textcolor{preprocessor}{  class FormatForComparison<CharType*, OtherOperand> \{                  \(\backslash\)}}
\DoxyCodeLine{333 \textcolor{preprocessor}{   public:                                                              \(\backslash\)}}
\DoxyCodeLine{334 \textcolor{preprocessor}{    static ::std::string Format(CharType* value) \{                      \(\backslash\)}}
\DoxyCodeLine{335 \textcolor{preprocessor}{      return ::testing::PrintToString(static\_cast<const void*>(value)); \(\backslash\)}}
\DoxyCodeLine{336 \textcolor{preprocessor}{    \}                                                                   \(\backslash\)}}
\DoxyCodeLine{337 \textcolor{preprocessor}{  \}}}
\DoxyCodeLine{338 }
\DoxyCodeLine{339 \mbox{\hyperlink{namespacetesting_1_1internal_a3682f962ae0ec1c0eca6444ca0a09e91}{GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_POINTER\_}}(\textcolor{keywordtype}{char});}
\DoxyCodeLine{340 \mbox{\hyperlink{namespacetesting_1_1internal_a3682f962ae0ec1c0eca6444ca0a09e91}{GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_POINTER\_}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char});}
\DoxyCodeLine{341 \mbox{\hyperlink{namespacetesting_1_1internal_a3682f962ae0ec1c0eca6444ca0a09e91}{GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_POINTER\_}}(\textcolor{keywordtype}{wchar\_t});}
\DoxyCodeLine{342 \mbox{\hyperlink{namespacetesting_1_1internal_a3682f962ae0ec1c0eca6444ca0a09e91}{GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_POINTER\_}}(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t});}
\DoxyCodeLine{343 }
\DoxyCodeLine{344 \textcolor{preprocessor}{\#undef GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_POINTER\_}}
\DoxyCodeLine{345 }
\DoxyCodeLine{346 \textcolor{comment}{// If a C string is compared with an STL string object, we know it's meant}}
\DoxyCodeLine{347 \textcolor{comment}{// to point to a NUL-\/terminated string, and thus can print it as a string.}}
\DoxyCodeLine{348 }
\DoxyCodeLine{349 \textcolor{preprocessor}{\#define GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_STRING\_(CharType, OtherStringType) \(\backslash\)}}
\DoxyCodeLine{350 \textcolor{preprocessor}{  template <>                                                           \(\backslash\)}}
\DoxyCodeLine{351 \textcolor{preprocessor}{  class FormatForComparison<CharType*, OtherStringType> \{               \(\backslash\)}}
\DoxyCodeLine{352 \textcolor{preprocessor}{   public:                                                              \(\backslash\)}}
\DoxyCodeLine{353 \textcolor{preprocessor}{    static ::std::string Format(CharType* value) \{                      \(\backslash\)}}
\DoxyCodeLine{354 \textcolor{preprocessor}{      return ::testing::PrintToString(value);                           \(\backslash\)}}
\DoxyCodeLine{355 \textcolor{preprocessor}{    \}                                                                   \(\backslash\)}}
\DoxyCodeLine{356 \textcolor{preprocessor}{  \}}}
\DoxyCodeLine{357 }
\DoxyCodeLine{358 \mbox{\hyperlink{namespacetesting_1_1internal_aeac30230dcc362221bdd07d61eaa4ec1}{GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_STRING\_}}(\textcolor{keywordtype}{char}, ::\mbox{\hyperlink{namespacetesting_1_1internal_a5ca8a348395a6145775c1a2334e21889}{std::string}});}
\DoxyCodeLine{359 \mbox{\hyperlink{namespacetesting_1_1internal_aeac30230dcc362221bdd07d61eaa4ec1}{GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_STRING\_}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}, ::\mbox{\hyperlink{namespacetesting_1_1internal_a5ca8a348395a6145775c1a2334e21889}{std::string}});}
\DoxyCodeLine{360 }
\DoxyCodeLine{361 \textcolor{preprocessor}{\#if GTEST\_HAS\_GLOBAL\_STRING}}
\DoxyCodeLine{362 \mbox{\hyperlink{namespacetesting_1_1internal_aeac30230dcc362221bdd07d61eaa4ec1}{GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_STRING\_}}(\textcolor{keywordtype}{char}, ::\textcolor{keywordtype}{string});}
\DoxyCodeLine{363 \mbox{\hyperlink{namespacetesting_1_1internal_aeac30230dcc362221bdd07d61eaa4ec1}{GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_STRING\_}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}, ::\textcolor{keywordtype}{string});}
\DoxyCodeLine{364 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{365 }
\DoxyCodeLine{366 \textcolor{preprocessor}{\#if GTEST\_HAS\_GLOBAL\_WSTRING}}
\DoxyCodeLine{367 \mbox{\hyperlink{namespacetesting_1_1internal_aeac30230dcc362221bdd07d61eaa4ec1}{GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_STRING\_}}(\textcolor{keywordtype}{wchar\_t}, ::\mbox{\hyperlink{namespacetesting_1_1internal_ac7f852174ed7a0a1b1e830b4bbd7c020}{wstring}});}
\DoxyCodeLine{368 \mbox{\hyperlink{namespacetesting_1_1internal_aeac30230dcc362221bdd07d61eaa4ec1}{GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_STRING\_}}(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}, ::\mbox{\hyperlink{namespacetesting_1_1internal_ac7f852174ed7a0a1b1e830b4bbd7c020}{wstring}});}
\DoxyCodeLine{369 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{370 }
\DoxyCodeLine{371 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_WSTRING}}
\DoxyCodeLine{372 \mbox{\hyperlink{namespacetesting_1_1internal_aeac30230dcc362221bdd07d61eaa4ec1}{GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_STRING\_}}(\textcolor{keywordtype}{wchar\_t}, ::\mbox{\hyperlink{namespacetesting_1_1internal_ac7f852174ed7a0a1b1e830b4bbd7c020}{std::wstring}});}
\DoxyCodeLine{373 \mbox{\hyperlink{namespacetesting_1_1internal_aeac30230dcc362221bdd07d61eaa4ec1}{GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_STRING\_}}(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}, ::\mbox{\hyperlink{namespacetesting_1_1internal_ac7f852174ed7a0a1b1e830b4bbd7c020}{std::wstring}});}
\DoxyCodeLine{374 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{375 }
\DoxyCodeLine{376 \textcolor{preprocessor}{\#undef GTEST\_IMPL\_FORMAT\_C\_STRING\_AS\_STRING\_}}
\DoxyCodeLine{377 }
\DoxyCodeLine{378 \textcolor{comment}{// Formats a comparison assertion (e.g. ASSERT\_EQ, EXPECT\_LT, and etc)}}
\DoxyCodeLine{379 \textcolor{comment}{// operand to be used in a failure message.  The type (but not value)}}
\DoxyCodeLine{380 \textcolor{comment}{// of the other operand may affect the format.  This allows us to}}
\DoxyCodeLine{381 \textcolor{comment}{// print a char* as a raw pointer when it is compared against another}}
\DoxyCodeLine{382 \textcolor{comment}{// char* or void*, and print it as a C string when it is compared}}
\DoxyCodeLine{383 \textcolor{comment}{// against an std::string object, for example.}}
\DoxyCodeLine{384 \textcolor{comment}{//}}
\DoxyCodeLine{385 \textcolor{comment}{// INTERNAL IMPLEMENTATION -\/ DO NOT USE IN A USER PROGRAM.}}
\DoxyCodeLine{386 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{387 \mbox{\hyperlink{namespacetesting_1_1internal_a5ca8a348395a6145775c1a2334e21889}{std::string}} \mbox{\hyperlink{namespacetesting_1_1internal_a91ab078f10adc669f09b7f604975c518}{FormatForComparisonFailureMessage}}(}
\DoxyCodeLine{388     \textcolor{keyword}{const} T1\& value, \textcolor{keyword}{const} T2\& \textcolor{comment}{/* other\_operand */}) \{}
\DoxyCodeLine{389   \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1_format_for_comparison_a2aeb688fc55b57abd3021d82eccad896}{FormatForComparison<T1, T2>::Format}}(value);}
\DoxyCodeLine{390 \}}
\DoxyCodeLine{391 }
\DoxyCodeLine{392 \textcolor{comment}{// UniversalPrinter<T>::Print(value, ostream\_ptr) prints the given}}
\DoxyCodeLine{393 \textcolor{comment}{// value to the given ostream.  The caller must ensure that}}
\DoxyCodeLine{394 \textcolor{comment}{// 'ostream\_ptr' is not NULL, or the behavior is undefined.}}
\DoxyCodeLine{395 \textcolor{comment}{//}}
\DoxyCodeLine{396 \textcolor{comment}{// We define UniversalPrinter as a class template (as opposed to a}}
\DoxyCodeLine{397 \textcolor{comment}{// function template), as we need to partially specialize it for}}
\DoxyCodeLine{398 \textcolor{comment}{// reference types, which cannot be done with function templates.}}
\DoxyCodeLine{399 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{400 \textcolor{keyword}{class }UniversalPrinter;}
\DoxyCodeLine{401 }
\DoxyCodeLine{402 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{403 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_a30708fa2bacf11895b03bdb21eb72309}{UniversalPrint}}(\textcolor{keyword}{const} T\& value, ::std::ostream* os);}
\DoxyCodeLine{404 }
\DoxyCodeLine{405 \textcolor{keyword}{enum} \mbox{\hyperlink{namespacetesting_1_1internal_a17fb8f0125fa92404a249ed38a43faa4}{DefaultPrinterType}} \{}
\DoxyCodeLine{406   \mbox{\hyperlink{namespacetesting_1_1internal_a17fb8f0125fa92404a249ed38a43faa4a945a19e59155ce1d335e8c3bcbdf61db}{kPrintContainer}},}
\DoxyCodeLine{407   \mbox{\hyperlink{namespacetesting_1_1internal_a17fb8f0125fa92404a249ed38a43faa4a8eaa6fff4a58832b30027df49f73dcbf}{kPrintPointer}},}
\DoxyCodeLine{408   \mbox{\hyperlink{namespacetesting_1_1internal_a17fb8f0125fa92404a249ed38a43faa4a5a066cde30e276c6460ba10d123d0c2c}{kPrintFunctionPointer}},}
\DoxyCodeLine{409   \mbox{\hyperlink{namespacetesting_1_1internal_a17fb8f0125fa92404a249ed38a43faa4a6f88d77d9d763d8a009caf950cfbab28}{kPrintOther}},}
\DoxyCodeLine{410 \};}
\DoxyCodeLine{411 \textcolor{keyword}{template} <DefaultPr\textcolor{keywordtype}{int}erType type> \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1_wrap_printer_type}{WrapPrinterType}} \{\};}
\DoxyCodeLine{412 }
\DoxyCodeLine{413 \textcolor{comment}{// Used to print an STL-\/style container when the user doesn't define}}
\DoxyCodeLine{414 \textcolor{comment}{// a PrintTo() for it.}}
\DoxyCodeLine{415 \textcolor{keyword}{template} <\textcolor{keyword}{typename} C>}
\DoxyCodeLine{416 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_a2e96c98d5bd8ee4a1b92f8e3cde7dd40}{DefaultPrintTo}}(\mbox{\hyperlink{structtesting_1_1internal_1_1_wrap_printer_type}{WrapPrinterType<kPrintContainer>}} \textcolor{comment}{/* dummy */},}
\DoxyCodeLine{417                     \textcolor{keyword}{const} C\& container, ::std::ostream* os) \{}
\DoxyCodeLine{418   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} kMaxCount = 32;  \textcolor{comment}{// The maximum number of elements to print.}}
\DoxyCodeLine{419   *os << \textcolor{charliteral}{'\{'};}
\DoxyCodeLine{420   \textcolor{keywordtype}{size\_t} count = 0;}
\DoxyCodeLine{421   \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} C::const\_iterator it = container.begin();}
\DoxyCodeLine{422        it != container.end(); ++it, ++count) \{}
\DoxyCodeLine{423     \textcolor{keywordflow}{if} (count > 0) \{}
\DoxyCodeLine{424       *os << \textcolor{charliteral}{','};}
\DoxyCodeLine{425       \textcolor{keywordflow}{if} (count == kMaxCount) \{  \textcolor{comment}{// Enough has been printed.}}
\DoxyCodeLine{426         *os << \textcolor{stringliteral}{"{} ..."{}};}
\DoxyCodeLine{427         \textcolor{keywordflow}{break};}
\DoxyCodeLine{428       \}}
\DoxyCodeLine{429     \}}
\DoxyCodeLine{430     *os << \textcolor{charliteral}{' '};}
\DoxyCodeLine{431     \textcolor{comment}{// We cannot call PrintTo(*it, os) here as PrintTo() doesn't}}
\DoxyCodeLine{432     \textcolor{comment}{// handle *it being a native array.}}
\DoxyCodeLine{433     \mbox{\hyperlink{namespacetesting_1_1internal_a30708fa2bacf11895b03bdb21eb72309}{internal::UniversalPrint}}(*it, os);}
\DoxyCodeLine{434   \}}
\DoxyCodeLine{435 }
\DoxyCodeLine{436   \textcolor{keywordflow}{if} (count > 0) \{}
\DoxyCodeLine{437     *os << \textcolor{charliteral}{' '};}
\DoxyCodeLine{438   \}}
\DoxyCodeLine{439   *os << \textcolor{charliteral}{'\}'};}
\DoxyCodeLine{440 \}}
\DoxyCodeLine{441 }
\DoxyCodeLine{442 \textcolor{comment}{// Used to print a pointer that is neither a char pointer nor a member}}
\DoxyCodeLine{443 \textcolor{comment}{// pointer, when the user doesn't define PrintTo() for it.  (A member}}
\DoxyCodeLine{444 \textcolor{comment}{// variable pointer or member function pointer doesn't really point to}}
\DoxyCodeLine{445 \textcolor{comment}{// a location in the address space.  Their representation is}}
\DoxyCodeLine{446 \textcolor{comment}{// implementation-\/defined.  Therefore they will be printed as raw}}
\DoxyCodeLine{447 \textcolor{comment}{// bytes.)}}
\DoxyCodeLine{448 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{449 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_a2e96c98d5bd8ee4a1b92f8e3cde7dd40}{DefaultPrintTo}}(\mbox{\hyperlink{structtesting_1_1internal_1_1_wrap_printer_type}{WrapPrinterType<kPrintPointer>}} \textcolor{comment}{/* dummy */},}
\DoxyCodeLine{450                     T* p, ::std::ostream* os) \{}
\DoxyCodeLine{451   \textcolor{keywordflow}{if} (p == NULL) \{}
\DoxyCodeLine{452     *os << \textcolor{stringliteral}{"{}NULL"{}};}
\DoxyCodeLine{453   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{454     \textcolor{comment}{// T is not a function type.  We just call << to print p,}}
\DoxyCodeLine{455     \textcolor{comment}{// relying on ADL to pick up user-\/defined << for their pointer}}
\DoxyCodeLine{456     \textcolor{comment}{// types, if any.}}
\DoxyCodeLine{457     *os << p;}
\DoxyCodeLine{458   \}}
\DoxyCodeLine{459 \}}
\DoxyCodeLine{460 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{461 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_a2e96c98d5bd8ee4a1b92f8e3cde7dd40}{DefaultPrintTo}}(\mbox{\hyperlink{structtesting_1_1internal_1_1_wrap_printer_type}{WrapPrinterType<kPrintFunctionPointer>}} \textcolor{comment}{/* dummy */},}
\DoxyCodeLine{462                     T* p, ::std::ostream* os) \{}
\DoxyCodeLine{463   \textcolor{keywordflow}{if} (p == NULL) \{}
\DoxyCodeLine{464     *os << \textcolor{stringliteral}{"{}NULL"{}};}
\DoxyCodeLine{465   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{466     \textcolor{comment}{// T is a function type, so '*os << p' doesn't do what we want}}
\DoxyCodeLine{467     \textcolor{comment}{// (it just prints p as bool).  We want to print p as a const}}
\DoxyCodeLine{468     \textcolor{comment}{// void*.}}
\DoxyCodeLine{469     *os << reinterpret\_cast<const void*>(p);}
\DoxyCodeLine{470   \}}
\DoxyCodeLine{471 \}}
\DoxyCodeLine{472 }
\DoxyCodeLine{473 \textcolor{comment}{// Used to print a non-\/container, non-\/pointer value when the user}}
\DoxyCodeLine{474 \textcolor{comment}{// doesn't define PrintTo() for it.}}
\DoxyCodeLine{475 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{476 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_a2e96c98d5bd8ee4a1b92f8e3cde7dd40}{DefaultPrintTo}}(\mbox{\hyperlink{structtesting_1_1internal_1_1_wrap_printer_type}{WrapPrinterType<kPrintOther>}} \textcolor{comment}{/* dummy */},}
\DoxyCodeLine{477                     \textcolor{keyword}{const} T\& value, ::std::ostream* os) \{}
\DoxyCodeLine{478   \mbox{\hyperlink{namespacetesting__internal_a3f49d3d0c996242f9d383c850097a656}{::testing\_internal::DefaultPrintNonContainerTo}}(value, os);}
\DoxyCodeLine{479 \}}
\DoxyCodeLine{480 }
\DoxyCodeLine{481 \textcolor{comment}{// Prints the given value using the << operator if it has one;}}
\DoxyCodeLine{482 \textcolor{comment}{// otherwise prints the bytes in it.  This is what}}
\DoxyCodeLine{483 \textcolor{comment}{// UniversalPrinter<T>::Print() does when PrintTo() is not specialized}}
\DoxyCodeLine{484 \textcolor{comment}{// or overloaded for type T.}}
\DoxyCodeLine{485 \textcolor{comment}{//}}
\DoxyCodeLine{486 \textcolor{comment}{// A user can override this behavior for a class type Foo by defining}}
\DoxyCodeLine{487 \textcolor{comment}{// an overload of PrintTo() in the namespace where Foo is defined.  We}}
\DoxyCodeLine{488 \textcolor{comment}{// give the user this option as sometimes defining a << operator for}}
\DoxyCodeLine{489 \textcolor{comment}{// Foo is not desirable (e.g. the coding style may prevent doing it,}}
\DoxyCodeLine{490 \textcolor{comment}{// or there is already a << operator but it doesn't do what the user}}
\DoxyCodeLine{491 \textcolor{comment}{// wants).}}
\DoxyCodeLine{492 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{493 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keyword}{const} T\& value, ::std::ostream* os) \{}
\DoxyCodeLine{494   \textcolor{comment}{// DefaultPrintTo() is overloaded.  The type of its first argument}}
\DoxyCodeLine{495   \textcolor{comment}{// determines which version will be picked.}}
\DoxyCodeLine{496   \textcolor{comment}{//}}
\DoxyCodeLine{497   \textcolor{comment}{// Note that we check for container types here, prior to we check}}
\DoxyCodeLine{498   \textcolor{comment}{// for protocol message types in our operator<<.  The rationale is:}}
\DoxyCodeLine{499   \textcolor{comment}{//}}
\DoxyCodeLine{500   \textcolor{comment}{// For protocol messages, we want to give people a chance to}}
\DoxyCodeLine{501   \textcolor{comment}{// override Google Mock's format by defining a PrintTo() or}}
\DoxyCodeLine{502   \textcolor{comment}{// operator<<.  For STL containers, other formats can be}}
\DoxyCodeLine{503   \textcolor{comment}{// incompatible with Google Mock's format for the container}}
\DoxyCodeLine{504   \textcolor{comment}{// elements; therefore we check for container types here to ensure}}
\DoxyCodeLine{505   \textcolor{comment}{// that our format is used.}}
\DoxyCodeLine{506   \textcolor{comment}{//}}
\DoxyCodeLine{507   \textcolor{comment}{// Note that MSVC and clang-\/cl do allow an implicit conversion from}}
\DoxyCodeLine{508   \textcolor{comment}{// pointer-\/to-\/function to pointer-\/to-\/object, but clang-\/cl warns on it.}}
\DoxyCodeLine{509   \textcolor{comment}{// So don't use ImplicitlyConvertible if it can be helped since it will}}
\DoxyCodeLine{510   \textcolor{comment}{// cause this warning, and use a separate overload of DefaultPrintTo for}}
\DoxyCodeLine{511   \textcolor{comment}{// function pointers so that the `*os << p` in the object pointer overload}}
\DoxyCodeLine{512   \textcolor{comment}{// doesn't cause that warning either.}}
\DoxyCodeLine{513   \mbox{\hyperlink{namespacetesting_1_1internal_a2e96c98d5bd8ee4a1b92f8e3cde7dd40}{DefaultPrintTo}}(}
\DoxyCodeLine{514       \mbox{\hyperlink{structtesting_1_1internal_1_1_wrap_printer_type}{WrapPrinterType}} <}
\DoxyCodeLine{515                   (\textcolor{keyword}{sizeof}(IsContainerTest<T>(0)) == \textcolor{keyword}{sizeof}(\mbox{\hyperlink{namespacetesting_1_1internal_ad8f0c2883245f1df2a53618a49f0deb3}{IsContainer}})) \&\&}
\DoxyCodeLine{516               !\mbox{\hyperlink{structtesting_1_1internal_1_1_is_recursive_container}{IsRecursiveContainer<T>::value}}}
\DoxyCodeLine{517           ? \mbox{\hyperlink{namespacetesting_1_1internal_a17fb8f0125fa92404a249ed38a43faa4a945a19e59155ce1d335e8c3bcbdf61db}{kPrintContainer}}}
\DoxyCodeLine{518           : !\mbox{\hyperlink{structtesting_1_1internal_1_1is__pointer}{is\_pointer<T>::value}}}
\DoxyCodeLine{519                 ? \mbox{\hyperlink{namespacetesting_1_1internal_a17fb8f0125fa92404a249ed38a43faa4a6f88d77d9d763d8a009caf950cfbab28}{kPrintOther}}}
\DoxyCodeLine{520 \#\textcolor{keywordflow}{if} \mbox{\hyperlink{gtest-port_8h_a6e310924e9ce4a9f8fda1b189cc680c4}{GTEST\_LANG\_CXX11}}}
\DoxyCodeLine{521                 : std::is\_function<\textcolor{keyword}{typename} std::remove\_pointer<T>::type>::value}
\DoxyCodeLine{522 \#\textcolor{keywordflow}{else}}
\DoxyCodeLine{523                 : !\mbox{\hyperlink{classtesting_1_1internal_1_1_implicitly_convertible}{internal::ImplicitlyConvertible<T, const void*>::value}}}
\DoxyCodeLine{524 \#endif}
\DoxyCodeLine{525                       ? \mbox{\hyperlink{namespacetesting_1_1internal_a17fb8f0125fa92404a249ed38a43faa4a5a066cde30e276c6460ba10d123d0c2c}{kPrintFunctionPointer}}}
\DoxyCodeLine{526                       : \mbox{\hyperlink{namespacetesting_1_1internal_a17fb8f0125fa92404a249ed38a43faa4a8eaa6fff4a58832b30027df49f73dcbf}{kPrintPointer}} > (),}
\DoxyCodeLine{527       value, os);}
\DoxyCodeLine{528 \}}
\DoxyCodeLine{529 }
\DoxyCodeLine{530 \textcolor{comment}{// The following list of PrintTo() overloads tells}}
\DoxyCodeLine{531 \textcolor{comment}{// UniversalPrinter<T>::Print() how to print standard types (built-\/in}}
\DoxyCodeLine{532 \textcolor{comment}{// types, strings, plain arrays, and pointers).}}
\DoxyCodeLine{533 }
\DoxyCodeLine{534 \textcolor{comment}{// Overloads for various char types.}}
\DoxyCodeLine{535 \mbox{\hyperlink{gtest-port_8h_aa73be6f0ba4a7456180a94904ce17790}{GTEST\_API\_}} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c, ::std::ostream* os);}
\DoxyCodeLine{536 \mbox{\hyperlink{gtest-port_8h_aa73be6f0ba4a7456180a94904ce17790}{GTEST\_API\_}} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} c, ::std::ostream* os);}
\DoxyCodeLine{537 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keywordtype}{char} c, ::std::ostream* os) \{}
\DoxyCodeLine{538   \textcolor{comment}{// When printing a plain char, we always treat it as unsigned.  This}}
\DoxyCodeLine{539   \textcolor{comment}{// way, the output won't be affected by whether the compiler thinks}}
\DoxyCodeLine{540   \textcolor{comment}{// char is signed or not.}}
\DoxyCodeLine{541   \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(c), os);}
\DoxyCodeLine{542 \}}
\DoxyCodeLine{543 }
\DoxyCodeLine{544 \textcolor{comment}{// Overloads for other simple built-\/in types.}}
\DoxyCodeLine{545 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keywordtype}{bool} x, ::std::ostream* os) \{}
\DoxyCodeLine{546   *os << (x ? \textcolor{stringliteral}{"{}true"{}} : \textcolor{stringliteral}{"{}false"{}});}
\DoxyCodeLine{547 \}}
\DoxyCodeLine{548 }
\DoxyCodeLine{549 \textcolor{comment}{// Overload for wchar\_t type.}}
\DoxyCodeLine{550 \textcolor{comment}{// Prints a wchar\_t as a symbol if it is printable or as its internal}}
\DoxyCodeLine{551 \textcolor{comment}{// code otherwise and also as its decimal code (except for L'\(\backslash\)0').}}
\DoxyCodeLine{552 \textcolor{comment}{// The L'\(\backslash\)0' char is printed as "{}L'\(\backslash\)\(\backslash\)0'"{}. The decimal code is printed}}
\DoxyCodeLine{553 \textcolor{comment}{// as signed integer when wchar\_t is implemented by the compiler}}
\DoxyCodeLine{554 \textcolor{comment}{// as a signed type and is printed as an unsigned integer when wchar\_t}}
\DoxyCodeLine{555 \textcolor{comment}{// is implemented as an unsigned type.}}
\DoxyCodeLine{556 \mbox{\hyperlink{gtest-port_8h_aa73be6f0ba4a7456180a94904ce17790}{GTEST\_API\_}} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keywordtype}{wchar\_t} wc, ::std::ostream* os);}
\DoxyCodeLine{557 }
\DoxyCodeLine{558 \textcolor{comment}{// Overloads for C strings.}}
\DoxyCodeLine{559 \mbox{\hyperlink{gtest-port_8h_aa73be6f0ba4a7456180a94904ce17790}{GTEST\_API\_}} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s, ::std::ostream* os);}
\DoxyCodeLine{560 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keywordtype}{char}* s, ::std::ostream* os) \{}
\DoxyCodeLine{561   \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(ImplicitCast\_<const char*>(s), os);}
\DoxyCodeLine{562 \}}
\DoxyCodeLine{563 }
\DoxyCodeLine{564 \textcolor{comment}{// signed/unsigned char is often used for representing binary data, so}}
\DoxyCodeLine{565 \textcolor{comment}{// we print pointers to it as void* to be safe.}}
\DoxyCodeLine{566 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keyword}{const} \textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}* s, ::std::ostream* os) \{}
\DoxyCodeLine{567   \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(ImplicitCast\_<const void*>(s), os);}
\DoxyCodeLine{568 \}}
\DoxyCodeLine{569 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}* s, ::std::ostream* os) \{}
\DoxyCodeLine{570   \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(ImplicitCast\_<const void*>(s), os);}
\DoxyCodeLine{571 \}}
\DoxyCodeLine{572 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* s, ::std::ostream* os) \{}
\DoxyCodeLine{573   \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(ImplicitCast\_<const void*>(s), os);}
\DoxyCodeLine{574 \}}
\DoxyCodeLine{575 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* s, ::std::ostream* os) \{}
\DoxyCodeLine{576   \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(ImplicitCast\_<const void*>(s), os);}
\DoxyCodeLine{577 \}}
\DoxyCodeLine{578 }
\DoxyCodeLine{579 \textcolor{comment}{// MSVC can be configured to define wchar\_t as a typedef of unsigned}}
\DoxyCodeLine{580 \textcolor{comment}{// short.  It defines \_NATIVE\_WCHAR\_T\_DEFINED when wchar\_t is a native}}
\DoxyCodeLine{581 \textcolor{comment}{// type.  When wchar\_t is a typedef, defining an overload for const}}
\DoxyCodeLine{582 \textcolor{comment}{// wchar\_t* would cause unsigned short* be printed as a wide string,}}
\DoxyCodeLine{583 \textcolor{comment}{// possibly causing invalid memory accesses.}}
\DoxyCodeLine{584 \textcolor{preprocessor}{\#if !defined(\_MSC\_VER) || defined(\_NATIVE\_WCHAR\_T\_DEFINED)}}
\DoxyCodeLine{585 \textcolor{comment}{// Overloads for wide C strings}}
\DoxyCodeLine{586 \mbox{\hyperlink{gtest-port_8h_aa73be6f0ba4a7456180a94904ce17790}{GTEST\_API\_}} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* s, ::std::ostream* os);}
\DoxyCodeLine{587 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\textcolor{keywordtype}{wchar\_t}* s, ::std::ostream* os) \{}
\DoxyCodeLine{588   \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(ImplicitCast\_<const wchar\_t*>(s), os);}
\DoxyCodeLine{589 \}}
\DoxyCodeLine{590 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{591 }
\DoxyCodeLine{592 \textcolor{comment}{// Overload for C arrays.  Multi-\/dimensional arrays are printed}}
\DoxyCodeLine{593 \textcolor{comment}{// properly.}}
\DoxyCodeLine{594 }
\DoxyCodeLine{595 \textcolor{comment}{// Prints the given number of elements in an array, without printing}}
\DoxyCodeLine{596 \textcolor{comment}{// the curly braces.}}
\DoxyCodeLine{597 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{598 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_ad3013b6b4c825edee9fe18ff1d982faa}{PrintRawArrayTo}}(\textcolor{keyword}{const} T a[], \textcolor{keywordtype}{size\_t} count, ::std::ostream* os) \{}
\DoxyCodeLine{599   \mbox{\hyperlink{namespacetesting_1_1internal_a30708fa2bacf11895b03bdb21eb72309}{UniversalPrint}}(a[0], os);}
\DoxyCodeLine{600   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 1; i != count; i++) \{}
\DoxyCodeLine{601     *os << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{602     \mbox{\hyperlink{namespacetesting_1_1internal_a30708fa2bacf11895b03bdb21eb72309}{UniversalPrint}}(a[i], os);}
\DoxyCodeLine{603   \}}
\DoxyCodeLine{604 \}}
\DoxyCodeLine{605 }
\DoxyCodeLine{606 \textcolor{comment}{// Overloads for ::string and ::std::string.}}
\DoxyCodeLine{607 \textcolor{preprocessor}{\#if GTEST\_HAS\_GLOBAL\_STRING}}
\DoxyCodeLine{608 \mbox{\hyperlink{gtest-port_8h_aa73be6f0ba4a7456180a94904ce17790}{GTEST\_API\_}} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_a8b53e46cea3f8bdfc9342057c4f6ba62}{PrintStringTo}}(\mbox{\hyperlink{namespacetesting_1_1internal_a5ca8a348395a6145775c1a2334e21889}{const ::string}}\&s, ::std::ostream* os);}
\DoxyCodeLine{609 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\mbox{\hyperlink{namespacetesting_1_1internal_a5ca8a348395a6145775c1a2334e21889}{const ::string}}\& s, ::std::ostream* os) \{}
\DoxyCodeLine{610   \mbox{\hyperlink{namespacetesting_1_1internal_a8b53e46cea3f8bdfc9342057c4f6ba62}{PrintStringTo}}(s, os);}
\DoxyCodeLine{611 \}}
\DoxyCodeLine{612 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_GLOBAL\_STRING}}
\DoxyCodeLine{613 }
\DoxyCodeLine{614 \mbox{\hyperlink{gtest-port_8h_aa73be6f0ba4a7456180a94904ce17790}{GTEST\_API\_}} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_a8b53e46cea3f8bdfc9342057c4f6ba62}{PrintStringTo}}(\mbox{\hyperlink{namespacetesting_1_1internal_a5ca8a348395a6145775c1a2334e21889}{const ::std::string}}\&s, ::std::ostream* os);}
\DoxyCodeLine{615 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\mbox{\hyperlink{namespacetesting_1_1internal_a5ca8a348395a6145775c1a2334e21889}{const ::std::string}}\& s, ::std::ostream* os) \{}
\DoxyCodeLine{616   \mbox{\hyperlink{namespacetesting_1_1internal_a8b53e46cea3f8bdfc9342057c4f6ba62}{PrintStringTo}}(s, os);}
\DoxyCodeLine{617 \}}
\DoxyCodeLine{618 }
\DoxyCodeLine{619 \textcolor{comment}{// Overloads for ::wstring and ::std::wstring.}}
\DoxyCodeLine{620 \textcolor{preprocessor}{\#if GTEST\_HAS\_GLOBAL\_WSTRING}}
\DoxyCodeLine{621 \mbox{\hyperlink{gtest-port_8h_aa73be6f0ba4a7456180a94904ce17790}{GTEST\_API\_}} \textcolor{keywordtype}{void} PrintWideStringTo(\mbox{\hyperlink{namespacetesting_1_1internal_ac7f852174ed7a0a1b1e830b4bbd7c020}{const ::wstring}}\&s, ::std::ostream* os);}
\DoxyCodeLine{622 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\mbox{\hyperlink{namespacetesting_1_1internal_ac7f852174ed7a0a1b1e830b4bbd7c020}{const ::wstring}}\& s, ::std::ostream* os) \{}
\DoxyCodeLine{623   PrintWideStringTo(s, os);}
\DoxyCodeLine{624 \}}
\DoxyCodeLine{625 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_GLOBAL\_WSTRING}}
\DoxyCodeLine{626 }
\DoxyCodeLine{627 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_WSTRING}}
\DoxyCodeLine{628 \mbox{\hyperlink{gtest-port_8h_aa73be6f0ba4a7456180a94904ce17790}{GTEST\_API\_}} \textcolor{keywordtype}{void} PrintWideStringTo(\mbox{\hyperlink{namespacetesting_1_1internal_ac7f852174ed7a0a1b1e830b4bbd7c020}{const ::std::wstring}}\&s, ::std::ostream* os);}
\DoxyCodeLine{629 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(\mbox{\hyperlink{namespacetesting_1_1internal_ac7f852174ed7a0a1b1e830b4bbd7c020}{const ::std::wstring}}\& s, ::std::ostream* os) \{}
\DoxyCodeLine{630   PrintWideStringTo(s, os);}
\DoxyCodeLine{631 \}}
\DoxyCodeLine{632 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_STD\_WSTRING}}
\DoxyCodeLine{633 }
\DoxyCodeLine{634 \textcolor{preprocessor}{\#if GTEST\_HAS\_ABSL}}
\DoxyCodeLine{635 \textcolor{comment}{// Overload for absl::string\_view.}}
\DoxyCodeLine{636 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(absl::string\_view sp, ::std::ostream* os) \{}
\DoxyCodeLine{637   \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(::\mbox{\hyperlink{namespacetesting_1_1internal_a5ca8a348395a6145775c1a2334e21889}{std::string}}(sp), os);}
\DoxyCodeLine{638 \}}
\DoxyCodeLine{639 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_ABSL}}
\DoxyCodeLine{640 }
\DoxyCodeLine{641 \textcolor{preprocessor}{\#if GTEST\_LANG\_CXX11}}
\DoxyCodeLine{642 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(std::nullptr\_t, ::std::ostream* os) \{ *os << \textcolor{stringliteral}{"{}(nullptr)"{}}; \}}
\DoxyCodeLine{643 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_LANG\_CXX11}}
\DoxyCodeLine{644 }
\DoxyCodeLine{645 \textcolor{preprocessor}{\#if GTEST\_HAS\_TR1\_TUPLE || GTEST\_HAS\_STD\_TUPLE\_}}
\DoxyCodeLine{646 \textcolor{comment}{// Helper function for printing a tuple.  T must be instantiated with}}
\DoxyCodeLine{647 \textcolor{comment}{// a tuple type.}}
\DoxyCodeLine{648 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{649 \textcolor{keywordtype}{void} PrintTupleTo(\textcolor{keyword}{const} T\& t, ::std::ostream* os);}
\DoxyCodeLine{650 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_TR1\_TUPLE || GTEST\_HAS\_STD\_TUPLE\_}}
\DoxyCodeLine{651 }
\DoxyCodeLine{652 \textcolor{preprocessor}{\#if GTEST\_HAS\_TR1\_TUPLE}}
\DoxyCodeLine{653 \textcolor{comment}{// Overload for ::std::tr1::tuple.  Needed for printing function arguments,}}
\DoxyCodeLine{654 \textcolor{comment}{// which are packed as tuples.}}
\DoxyCodeLine{655 }
\DoxyCodeLine{656 \textcolor{comment}{// Overloaded PrintTo() for tuples of various arities.  We support}}
\DoxyCodeLine{657 \textcolor{comment}{// tuples of up-\/to 10 fields.  The following implementation works}}
\DoxyCodeLine{658 \textcolor{comment}{// regardless of whether tr1::tuple is implemented using the}}
\DoxyCodeLine{659 \textcolor{comment}{// non-\/standard variadic template feature or not.}}
\DoxyCodeLine{660 }
\DoxyCodeLine{661 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(const ::std::tr1::tuple<>\& t, ::std::ostream* os) \{}
\DoxyCodeLine{662   PrintTupleTo(t, os);}
\DoxyCodeLine{663 \}}
\DoxyCodeLine{664 }
\DoxyCodeLine{665 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{666 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(const ::std::tr1::tuple<T1>\& t, ::std::ostream* os) \{}
\DoxyCodeLine{667   PrintTupleTo(t, os);}
\DoxyCodeLine{668 \}}
\DoxyCodeLine{669 }
\DoxyCodeLine{670 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{671 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(const ::std::tr1::tuple<T1, T2>\& t, ::std::ostream* os) \{}
\DoxyCodeLine{672   PrintTupleTo(t, os);}
\DoxyCodeLine{673 \}}
\DoxyCodeLine{674 }
\DoxyCodeLine{675 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} T3>}
\DoxyCodeLine{676 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(const ::std::tr1::tuple<T1, T2, T3>\& t, ::std::ostream* os) \{}
\DoxyCodeLine{677   PrintTupleTo(t, os);}
\DoxyCodeLine{678 \}}
\DoxyCodeLine{679 }
\DoxyCodeLine{680 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} T3, \textcolor{keyword}{typename} T4>}
\DoxyCodeLine{681 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(const ::std::tr1::tuple<T1, T2, T3, T4>\& t, ::std::ostream* os) \{}
\DoxyCodeLine{682   PrintTupleTo(t, os);}
\DoxyCodeLine{683 \}}
\DoxyCodeLine{684 }
\DoxyCodeLine{685 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} T3, \textcolor{keyword}{typename} T4, \textcolor{keyword}{typename} T5>}
\DoxyCodeLine{686 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(const ::std::tr1::tuple<T1, T2, T3, T4, T5>\& t,}
\DoxyCodeLine{687              ::std::ostream* os) \{}
\DoxyCodeLine{688   PrintTupleTo(t, os);}
\DoxyCodeLine{689 \}}
\DoxyCodeLine{690 }
\DoxyCodeLine{691 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} T3, \textcolor{keyword}{typename} T4, \textcolor{keyword}{typename} T5,}
\DoxyCodeLine{692           \textcolor{keyword}{typename} T6>}
\DoxyCodeLine{693 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6>\& t,}
\DoxyCodeLine{694              ::std::ostream* os) \{}
\DoxyCodeLine{695   PrintTupleTo(t, os);}
\DoxyCodeLine{696 \}}
\DoxyCodeLine{697 }
\DoxyCodeLine{698 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} T3, \textcolor{keyword}{typename} T4, \textcolor{keyword}{typename} T5,}
\DoxyCodeLine{699           \textcolor{keyword}{typename} T6, \textcolor{keyword}{typename} T7>}
\DoxyCodeLine{700 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7>\& t,}
\DoxyCodeLine{701              ::std::ostream* os) \{}
\DoxyCodeLine{702   PrintTupleTo(t, os);}
\DoxyCodeLine{703 \}}
\DoxyCodeLine{704 }
\DoxyCodeLine{705 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} T3, \textcolor{keyword}{typename} T4, \textcolor{keyword}{typename} T5,}
\DoxyCodeLine{706           \textcolor{keyword}{typename} T6, \textcolor{keyword}{typename} T7, \textcolor{keyword}{typename} T8>}
\DoxyCodeLine{707 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8>\& t,}
\DoxyCodeLine{708              ::std::ostream* os) \{}
\DoxyCodeLine{709   PrintTupleTo(t, os);}
\DoxyCodeLine{710 \}}
\DoxyCodeLine{711 }
\DoxyCodeLine{712 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} T3, \textcolor{keyword}{typename} T4, \textcolor{keyword}{typename} T5,}
\DoxyCodeLine{713           \textcolor{keyword}{typename} T6, \textcolor{keyword}{typename} T7, \textcolor{keyword}{typename} T8, \textcolor{keyword}{typename} T9>}
\DoxyCodeLine{714 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>\& t,}
\DoxyCodeLine{715              ::std::ostream* os) \{}
\DoxyCodeLine{716   PrintTupleTo(t, os);}
\DoxyCodeLine{717 \}}
\DoxyCodeLine{718 }
\DoxyCodeLine{719 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} T3, \textcolor{keyword}{typename} T4, \textcolor{keyword}{typename} T5,}
\DoxyCodeLine{720           \textcolor{keyword}{typename} T6, \textcolor{keyword}{typename} T7, \textcolor{keyword}{typename} T8, \textcolor{keyword}{typename} T9, \textcolor{keyword}{typename} T10>}
\DoxyCodeLine{721 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(}
\DoxyCodeLine{722     const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>\& t,}
\DoxyCodeLine{723     ::std::ostream* os) \{}
\DoxyCodeLine{724   PrintTupleTo(t, os);}
\DoxyCodeLine{725 \}}
\DoxyCodeLine{726 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_TR1\_TUPLE}}
\DoxyCodeLine{727 }
\DoxyCodeLine{728 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_TUPLE\_}}
\DoxyCodeLine{729 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Types>}
\DoxyCodeLine{730 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(const ::std::tuple<Types...>\& t, ::std::ostream* os) \{}
\DoxyCodeLine{731   PrintTupleTo(t, os);}
\DoxyCodeLine{732 \}}
\DoxyCodeLine{733 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_STD\_TUPLE\_}}
\DoxyCodeLine{734 }
\DoxyCodeLine{735 \textcolor{comment}{// Overload for std::pair.}}
\DoxyCodeLine{736 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{737 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(const ::std::pair<T1, T2>\& value, ::std::ostream* os) \{}
\DoxyCodeLine{738   *os << \textcolor{charliteral}{'('};}
\DoxyCodeLine{739   \textcolor{comment}{// We cannot use UniversalPrint(value.first, os) here, as T1 may be}}
\DoxyCodeLine{740   \textcolor{comment}{// a reference type.  The same for printing value.second.}}
\DoxyCodeLine{741   \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_printer_aecec021e1abbaa260b701e24e3fe33eb}{UniversalPrinter<T1>::Print}}(value.first, os);}
\DoxyCodeLine{742   *os << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{743   \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_printer_aecec021e1abbaa260b701e24e3fe33eb}{UniversalPrinter<T2>::Print}}(value.second, os);}
\DoxyCodeLine{744   *os << \textcolor{charliteral}{')'};}
\DoxyCodeLine{745 \}}
\DoxyCodeLine{746 }
\DoxyCodeLine{747 \textcolor{comment}{// Implements printing a non-\/reference type T by letting the compiler}}
\DoxyCodeLine{748 \textcolor{comment}{// pick the right overload of PrintTo() for T.}}
\DoxyCodeLine{749 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{750 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1_universal_printer}{UniversalPrinter}} \{}
\DoxyCodeLine{751  \textcolor{keyword}{public}:}
\DoxyCodeLine{752   \textcolor{comment}{// MSVC warns about adding const to a function type, so we want to}}
\DoxyCodeLine{753   \textcolor{comment}{// disable the warning.}}
\DoxyCodeLine{754   \mbox{\hyperlink{gtest-port_8h_a86994cc68e844d8b82089c70408dfc61}{GTEST\_DISABLE\_MSC\_WARNINGS\_PUSH\_}}(4180)}
\DoxyCodeLine{755 }
\DoxyCodeLine{756   \textcolor{comment}{// Note: we deliberately don't call this PrintTo(), as that name}}
\DoxyCodeLine{757   \textcolor{comment}{// conflicts with ::testing::internal::PrintTo in the body of the}}
\DoxyCodeLine{758   \textcolor{comment}{// function.}}
\DoxyCodeLine{759   static \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_printer_aecec021e1abbaa260b701e24e3fe33eb}{Print}}(const T\& value, ::\mbox{\hyperlink{namespacestd}{std}}::ostream* os) \{}
\DoxyCodeLine{760     \textcolor{comment}{// By default, ::testing::internal::PrintTo() is used for printing}}
\DoxyCodeLine{761     \textcolor{comment}{// the value.}}
\DoxyCodeLine{762     \textcolor{comment}{//}}
\DoxyCodeLine{763     \textcolor{comment}{// Thanks to Koenig look-\/up, if T is a class and has its own}}
\DoxyCodeLine{764     \textcolor{comment}{// PrintTo() function defined in its namespace, that function will}}
\DoxyCodeLine{765     \textcolor{comment}{// be visible here.  Since it is more specific than the generic ones}}
\DoxyCodeLine{766     \textcolor{comment}{// in ::testing::internal, it will be picked by the compiler in the}}
\DoxyCodeLine{767     \textcolor{comment}{// following statement -\/ exactly what we want.}}
\DoxyCodeLine{768     \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{PrintTo}}(value, os);}
\DoxyCodeLine{769   \}}
\DoxyCodeLine{770 }
\DoxyCodeLine{771   \mbox{\hyperlink{gtest-port_8h_ab4c44546d6d9aced68993b87b608fc06}{GTEST\_DISABLE\_MSC\_WARNINGS\_POP\_}}()}
\DoxyCodeLine{772 \};}
\DoxyCodeLine{773 }
\DoxyCodeLine{774 \textcolor{preprocessor}{\#if GTEST\_HAS\_ABSL}}
\DoxyCodeLine{775 }
\DoxyCodeLine{776 \textcolor{comment}{// Printer for absl::optional}}
\DoxyCodeLine{777 }
\DoxyCodeLine{778 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{779 \textcolor{keyword}{class }UniversalPrinter<::absl::optional<T>> \{}
\DoxyCodeLine{780  \textcolor{keyword}{public}:}
\DoxyCodeLine{781   \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_printer_aecec021e1abbaa260b701e24e3fe33eb}{Print}}(const ::absl::optional<T>\& value, ::std::ostream* os) \{}
\DoxyCodeLine{782     *os << \textcolor{charliteral}{'('};}
\DoxyCodeLine{783     \textcolor{keywordflow}{if} (!value) \{}
\DoxyCodeLine{784       *os << \textcolor{stringliteral}{"{}nullopt"{}};}
\DoxyCodeLine{785     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{786       \mbox{\hyperlink{namespacetesting_1_1internal_a30708fa2bacf11895b03bdb21eb72309}{UniversalPrint}}(*value, os);}
\DoxyCodeLine{787     \}}
\DoxyCodeLine{788     *os << \textcolor{charliteral}{')'};}
\DoxyCodeLine{789   \}}
\DoxyCodeLine{790 \};}
\DoxyCodeLine{791 }
\DoxyCodeLine{792 \textcolor{comment}{// Printer for absl::variant}}
\DoxyCodeLine{793 }
\DoxyCodeLine{794 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{795 \textcolor{keyword}{class }UniversalPrinter<::absl::variant<T...>> \{}
\DoxyCodeLine{796  \textcolor{keyword}{public}:}
\DoxyCodeLine{797   \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_printer_aecec021e1abbaa260b701e24e3fe33eb}{Print}}(const ::absl::variant<T...>\& value, ::std::ostream* os) \{}
\DoxyCodeLine{798     *os << \textcolor{charliteral}{'('};}
\DoxyCodeLine{799     absl::visit(Visitor\{os\}, value);}
\DoxyCodeLine{800     *os << \textcolor{charliteral}{')'};}
\DoxyCodeLine{801   \}}
\DoxyCodeLine{802 }
\DoxyCodeLine{803  \textcolor{keyword}{private}:}
\DoxyCodeLine{804   \textcolor{keyword}{struct }Visitor \{}
\DoxyCodeLine{805     \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{806     \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} U\& u)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{807       *os << \textcolor{stringliteral}{"{}'"{}} << GetTypeName<U>() << \textcolor{stringliteral}{"{}' with value "{}};}
\DoxyCodeLine{808       \mbox{\hyperlink{namespacetesting_1_1internal_a30708fa2bacf11895b03bdb21eb72309}{UniversalPrint}}(u, os);}
\DoxyCodeLine{809     \}}
\DoxyCodeLine{810     ::std::ostream* os;}
\DoxyCodeLine{811   \};}
\DoxyCodeLine{812 \};}
\DoxyCodeLine{813 }
\DoxyCodeLine{814 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_ABSL}}
\DoxyCodeLine{815 }
\DoxyCodeLine{816 \textcolor{comment}{// UniversalPrintArray(begin, len, os) prints an array of 'len'}}
\DoxyCodeLine{817 \textcolor{comment}{// elements, starting at address 'begin'.}}
\DoxyCodeLine{818 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{819 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_ad79d71c3110f8eb24ab352d68f29436a}{UniversalPrintArray}}(\textcolor{keyword}{const} T* begin, \textcolor{keywordtype}{size\_t} len, ::std::ostream* os) \{}
\DoxyCodeLine{820   \textcolor{keywordflow}{if} (len == 0) \{}
\DoxyCodeLine{821     *os << \textcolor{stringliteral}{"{}\{\}"{}};}
\DoxyCodeLine{822   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{823     *os << \textcolor{stringliteral}{"{}\{ "{}};}
\DoxyCodeLine{824     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} kThreshold = 18;}
\DoxyCodeLine{825     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} kChunkSize = 8;}
\DoxyCodeLine{826     \textcolor{comment}{// If the array has more than kThreshold elements, we'll have to}}
\DoxyCodeLine{827     \textcolor{comment}{// omit some details by printing only the first and the last}}
\DoxyCodeLine{828     \textcolor{comment}{// kChunkSize elements.}}
\DoxyCodeLine{829     \textcolor{comment}{// FIXME: let the user control the threshold using a flag.}}
\DoxyCodeLine{830     \textcolor{keywordflow}{if} (len <= kThreshold) \{}
\DoxyCodeLine{831       \mbox{\hyperlink{namespacetesting_1_1internal_ad3013b6b4c825edee9fe18ff1d982faa}{PrintRawArrayTo}}(begin, len, os);}
\DoxyCodeLine{832     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{833       \mbox{\hyperlink{namespacetesting_1_1internal_ad3013b6b4c825edee9fe18ff1d982faa}{PrintRawArrayTo}}(begin, kChunkSize, os);}
\DoxyCodeLine{834       *os << \textcolor{stringliteral}{"{}, ..., "{}};}
\DoxyCodeLine{835       \mbox{\hyperlink{namespacetesting_1_1internal_ad3013b6b4c825edee9fe18ff1d982faa}{PrintRawArrayTo}}(begin + len -\/ kChunkSize, kChunkSize, os);}
\DoxyCodeLine{836     \}}
\DoxyCodeLine{837     *os << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{838   \}}
\DoxyCodeLine{839 \}}
\DoxyCodeLine{840 \textcolor{comment}{// This overload prints a (const) char array compactly.}}
\DoxyCodeLine{841 \mbox{\hyperlink{gtest-port_8h_aa73be6f0ba4a7456180a94904ce17790}{GTEST\_API\_}} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_ad79d71c3110f8eb24ab352d68f29436a}{UniversalPrintArray}}(}
\DoxyCodeLine{842     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* begin, \textcolor{keywordtype}{size\_t} len, ::std::ostream* os);}
\DoxyCodeLine{843 }
\DoxyCodeLine{844 \textcolor{comment}{// This overload prints a (const) wchar\_t array compactly.}}
\DoxyCodeLine{845 \mbox{\hyperlink{gtest-port_8h_aa73be6f0ba4a7456180a94904ce17790}{GTEST\_API\_}} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_ad79d71c3110f8eb24ab352d68f29436a}{UniversalPrintArray}}(}
\DoxyCodeLine{846     \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* begin, \textcolor{keywordtype}{size\_t} len, ::std::ostream* os);}
\DoxyCodeLine{847 }
\DoxyCodeLine{848 \textcolor{comment}{// Implements printing an array type T[N].}}
\DoxyCodeLine{849 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{850 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1_universal_printer}{UniversalPrinter}}<T[N]> \{}
\DoxyCodeLine{851  \textcolor{keyword}{public}:}
\DoxyCodeLine{852   \textcolor{comment}{// Prints the given array, omitting some elements when there are too}}
\DoxyCodeLine{853   \textcolor{comment}{// many.}}
\DoxyCodeLine{854   \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_printer_3_01_t_0f_n_0e_4_a1cf0e7c8db59c090f769116c6421b212}{Print}}(\textcolor{keyword}{const} T (\&a)[N], ::std::ostream* os) \{}
\DoxyCodeLine{855     \mbox{\hyperlink{namespacetesting_1_1internal_ad79d71c3110f8eb24ab352d68f29436a}{UniversalPrintArray}}(a, N, os);}
\DoxyCodeLine{856   \}}
\DoxyCodeLine{857 \};}
\DoxyCodeLine{858 }
\DoxyCodeLine{859 \textcolor{comment}{// Implements printing a reference type T\&.}}
\DoxyCodeLine{860 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{861 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1_universal_printer}{UniversalPrinter}}<T\&> \{}
\DoxyCodeLine{862  \textcolor{keyword}{public}:}
\DoxyCodeLine{863   \textcolor{comment}{// MSVC warns about adding const to a function type, so we want to}}
\DoxyCodeLine{864   \textcolor{comment}{// disable the warning.}}
\DoxyCodeLine{865   \mbox{\hyperlink{gtest-port_8h_a86994cc68e844d8b82089c70408dfc61}{GTEST\_DISABLE\_MSC\_WARNINGS\_PUSH\_}}(4180)}
\DoxyCodeLine{866 }
\DoxyCodeLine{867   static \textcolor{keywordtype}{void} Print(const T\& value, ::\mbox{\hyperlink{namespacestd}{std}}::ostream* os) \{}
\DoxyCodeLine{868     \textcolor{comment}{// Prints the address of the value.  We use reinterpret\_cast here}}
\DoxyCodeLine{869     \textcolor{comment}{// as static\_cast doesn't compile when T is a function type.}}
\DoxyCodeLine{870     *os << \textcolor{stringliteral}{"{}@"{}} << \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&value) << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{871 }
\DoxyCodeLine{872     \textcolor{comment}{// Then prints the value itself.}}
\DoxyCodeLine{873     \mbox{\hyperlink{namespacetesting_1_1internal_a30708fa2bacf11895b03bdb21eb72309}{UniversalPrint}}(value, os);}
\DoxyCodeLine{874   \}}
\DoxyCodeLine{875 }
\DoxyCodeLine{876   \mbox{\hyperlink{gtest-port_8h_ab4c44546d6d9aced68993b87b608fc06}{GTEST\_DISABLE\_MSC\_WARNINGS\_POP\_}}()}
\DoxyCodeLine{877 \};}
\DoxyCodeLine{878 }
\DoxyCodeLine{879 \textcolor{comment}{// Prints a value tersely: for a reference type, the referenced value}}
\DoxyCodeLine{880 \textcolor{comment}{// (but not the address) is printed; for a (const) char pointer, the}}
\DoxyCodeLine{881 \textcolor{comment}{// NUL-\/terminated string (but not the pointer) is printed.}}
\DoxyCodeLine{882 }
\DoxyCodeLine{883 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{884 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer}{UniversalTersePrinter}} \{}
\DoxyCodeLine{885  \textcolor{keyword}{public}:}
\DoxyCodeLine{886   \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer_a042249cdb42fdb77588c9ad54ea7ed54}{Print}}(\textcolor{keyword}{const} T\& value, ::std::ostream* os) \{}
\DoxyCodeLine{887     \mbox{\hyperlink{namespacetesting_1_1internal_a30708fa2bacf11895b03bdb21eb72309}{UniversalPrint}}(value, os);}
\DoxyCodeLine{888   \}}
\DoxyCodeLine{889 \};}
\DoxyCodeLine{890 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{891 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer}{UniversalTersePrinter}}<T\&> \{}
\DoxyCodeLine{892  \textcolor{keyword}{public}:}
\DoxyCodeLine{893   \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer_3_01_t_01_6_01_4_a931f93cc52a3046706c87d0a90640483}{Print}}(\textcolor{keyword}{const} T\& value, ::std::ostream* os) \{}
\DoxyCodeLine{894     \mbox{\hyperlink{namespacetesting_1_1internal_a30708fa2bacf11895b03bdb21eb72309}{UniversalPrint}}(value, os);}
\DoxyCodeLine{895   \}}
\DoxyCodeLine{896 \};}
\DoxyCodeLine{897 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{898 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer}{UniversalTersePrinter}}<T[N]> \{}
\DoxyCodeLine{899  \textcolor{keyword}{public}:}
\DoxyCodeLine{900   \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer_3_01_t_0f_n_0e_4_a9e0ceb62fda7dc46ebcf5f911e459a49}{Print}}(\textcolor{keyword}{const} T (\&value)[N], ::std::ostream* os) \{}
\DoxyCodeLine{901     \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_printer_aecec021e1abbaa260b701e24e3fe33eb}{UniversalPrinter<T[N]>::Print}}(value, os);}
\DoxyCodeLine{902   \}}
\DoxyCodeLine{903 \};}
\DoxyCodeLine{904 \textcolor{keyword}{template} <>}
\DoxyCodeLine{905 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer}{UniversalTersePrinter}}<const char*> \{}
\DoxyCodeLine{906  \textcolor{keyword}{public}:}
\DoxyCodeLine{907   \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer_3_01const_01char_01_5_01_4_a37a3be2d26dc07b24d16c2b5eb88ecda}{Print}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str, ::std::ostream* os) \{}
\DoxyCodeLine{908     \textcolor{keywordflow}{if} (str == NULL) \{}
\DoxyCodeLine{909       *os << \textcolor{stringliteral}{"{}NULL"{}};}
\DoxyCodeLine{910     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{911       \mbox{\hyperlink{namespacetesting_1_1internal_a30708fa2bacf11895b03bdb21eb72309}{UniversalPrint}}(\mbox{\hyperlink{namespacetesting_1_1internal_a5ca8a348395a6145775c1a2334e21889}{std::string}}(str), os);}
\DoxyCodeLine{912     \}}
\DoxyCodeLine{913   \}}
\DoxyCodeLine{914 \};}
\DoxyCodeLine{915 \textcolor{keyword}{template} <>}
\DoxyCodeLine{916 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer}{UniversalTersePrinter}}<char*> \{}
\DoxyCodeLine{917  \textcolor{keyword}{public}:}
\DoxyCodeLine{918   \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer_3_01char_01_5_01_4_aa9ef95587c1461fe33e254af52401a43}{Print}}(\textcolor{keywordtype}{char}* str, ::std::ostream* os) \{}
\DoxyCodeLine{919     \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer_a042249cdb42fdb77588c9ad54ea7ed54}{UniversalTersePrinter<const char*>::Print}}(str, os);}
\DoxyCodeLine{920   \}}
\DoxyCodeLine{921 \};}
\DoxyCodeLine{922 }
\DoxyCodeLine{923 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_WSTRING}}
\DoxyCodeLine{924 \textcolor{keyword}{template} <>}
\DoxyCodeLine{925 \textcolor{keyword}{class }UniversalTersePrinter<const wchar\_t*> \{}
\DoxyCodeLine{926  \textcolor{keyword}{public}:}
\DoxyCodeLine{927   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Print(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* str, ::std::ostream* os) \{}
\DoxyCodeLine{928     \textcolor{keywordflow}{if} (str == NULL) \{}
\DoxyCodeLine{929       *os << \textcolor{stringliteral}{"{}NULL"{}};}
\DoxyCodeLine{930     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{931       \mbox{\hyperlink{namespacetesting_1_1internal_a30708fa2bacf11895b03bdb21eb72309}{UniversalPrint}}(::\mbox{\hyperlink{namespacetesting_1_1internal_ac7f852174ed7a0a1b1e830b4bbd7c020}{std::wstring}}(str), os);}
\DoxyCodeLine{932     \}}
\DoxyCodeLine{933   \}}
\DoxyCodeLine{934 \};}
\DoxyCodeLine{935 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{936 }
\DoxyCodeLine{937 \textcolor{keyword}{template} <>}
\DoxyCodeLine{938 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer}{UniversalTersePrinter}}<wchar\_t*> \{}
\DoxyCodeLine{939  \textcolor{keyword}{public}:}
\DoxyCodeLine{940   \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer_3_01wchar__t_01_5_01_4_a9cdf673b44d19e6879253f30f11cd740}{Print}}(\textcolor{keywordtype}{wchar\_t}* str, ::std::ostream* os) \{}
\DoxyCodeLine{941     \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer_a042249cdb42fdb77588c9ad54ea7ed54}{UniversalTersePrinter<const wchar\_t*>::Print}}(str, os);}
\DoxyCodeLine{942   \}}
\DoxyCodeLine{943 \};}
\DoxyCodeLine{944 }
\DoxyCodeLine{945 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{946 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_afa92f5a284929dc3723e654a25feb7b9}{UniversalTersePrint}}(\textcolor{keyword}{const} T\& value, ::std::ostream* os) \{}
\DoxyCodeLine{947   \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer_a042249cdb42fdb77588c9ad54ea7ed54}{UniversalTersePrinter<T>::Print}}(value, os);}
\DoxyCodeLine{948 \}}
\DoxyCodeLine{949 }
\DoxyCodeLine{950 \textcolor{comment}{// Prints a value using the type inferred by the compiler.  The}}
\DoxyCodeLine{951 \textcolor{comment}{// difference between this and UniversalTersePrint() is that for a}}
\DoxyCodeLine{952 \textcolor{comment}{// (const) char pointer, this prints both the pointer and the}}
\DoxyCodeLine{953 \textcolor{comment}{// NUL-\/terminated string.}}
\DoxyCodeLine{954 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{955 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacetesting_1_1internal_a30708fa2bacf11895b03bdb21eb72309}{UniversalPrint}}(\textcolor{keyword}{const} T\& value, ::std::ostream* os) \{}
\DoxyCodeLine{956   \textcolor{comment}{// A workarond for the bug in VC++ 7.1 that prevents us from instantiating}}
\DoxyCodeLine{957   \textcolor{comment}{// UniversalPrinter with T directly.}}
\DoxyCodeLine{958   \textcolor{keyword}{typedef} T T1;}
\DoxyCodeLine{959   \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_printer_aecec021e1abbaa260b701e24e3fe33eb}{UniversalPrinter<T1>::Print}}(value, os);}
\DoxyCodeLine{960 \}}
\DoxyCodeLine{961 }
\DoxyCodeLine{962 typedef ::std::vector< ::std::string> \mbox{\hyperlink{namespacetesting_1_1internal_a50003bb76ec2934be1062be11efba8bf}{Strings}};}
\DoxyCodeLine{963 }
\DoxyCodeLine{964 \textcolor{comment}{// TuplePolicy<TupleT> must provide:}}
\DoxyCodeLine{965 \textcolor{comment}{// -\/ tuple\_size}}
\DoxyCodeLine{966 \textcolor{comment}{//     size of tuple TupleT.}}
\DoxyCodeLine{967 \textcolor{comment}{// -\/ get<size\_t I>(const TupleT\& t)}}
\DoxyCodeLine{968 \textcolor{comment}{//     static function extracting element I of tuple TupleT.}}
\DoxyCodeLine{969 \textcolor{comment}{// -\/ tuple\_element<size\_t I>::type}}
\DoxyCodeLine{970 \textcolor{comment}{//     type of element I of tuple TupleT.}}
\DoxyCodeLine{971 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TupleT>}
\DoxyCodeLine{972 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1_tuple_policy}{TuplePolicy}};}
\DoxyCodeLine{973 }
\DoxyCodeLine{974 \textcolor{preprocessor}{\#if GTEST\_HAS\_TR1\_TUPLE}}
\DoxyCodeLine{975 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TupleT>}
\DoxyCodeLine{976 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1_tuple_policy}{TuplePolicy}} \{}
\DoxyCodeLine{977   \textcolor{keyword}{typedef} TupleT Tuple;}
\DoxyCodeLine{978   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} tuple\_size = \mbox{\hyperlink{structstd_1_1tr1_1_1tuple__size}{::std::tr1::tuple\_size<Tuple>::value}};}
\DoxyCodeLine{979 }
\DoxyCodeLine{980   \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{981   \textcolor{keyword}{struct }tuple\_element : \mbox{\hyperlink{structstd_1_1tr1_1_1tuple__element}{::std::tr1::tuple\_element}}<static\_cast<int>(I), Tuple> \{}
\DoxyCodeLine{982   \};}
\DoxyCodeLine{983 }
\DoxyCodeLine{984   \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{985   \textcolor{keyword}{static} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1_add_reference}{AddReference}}<\textcolor{keyword}{const} typename ::std::tr1::tuple\_element<}
\DoxyCodeLine{986       \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(I), Tuple>::type>::type}
\DoxyCodeLine{987   get(\textcolor{keyword}{const} Tuple\& tuple) \{}
\DoxyCodeLine{988     return ::std::tr1::get<I>(tuple);}
\DoxyCodeLine{989   \}}
\DoxyCodeLine{990 \};}
\DoxyCodeLine{991 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TupleT>}
\DoxyCodeLine{992 \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} TuplePolicy<TupleT>::tuple\_size;}
\DoxyCodeLine{993 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_TR1\_TUPLE}}
\DoxyCodeLine{994 }
\DoxyCodeLine{995 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_TUPLE\_}}
\DoxyCodeLine{996 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Types>}
\DoxyCodeLine{997 \textcolor{keyword}{struct }TuplePolicy< ::std::tuple<Types...> > \{}
\DoxyCodeLine{998   \textcolor{keyword}{typedef} ::std::tuple<Types...> Tuple;}
\DoxyCodeLine{999   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} tuple\_size = ::std::tuple\_size<Tuple>::value;}
\DoxyCodeLine{1000 }
\DoxyCodeLine{1001   \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{1002   \textcolor{keyword}{struct }tuple\_element : ::std::tuple\_element<I, Tuple> \{\};}
\DoxyCodeLine{1003 }
\DoxyCodeLine{1004   \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{1005   \textcolor{keyword}{static} \textcolor{keyword}{const} typename ::std::tuple\_element<I, Tuple>::type\& get(}
\DoxyCodeLine{1006       \textcolor{keyword}{const} Tuple\& tuple) \{}
\DoxyCodeLine{1007     return ::std::get<I>(tuple);}
\DoxyCodeLine{1008   \}}
\DoxyCodeLine{1009 \};}
\DoxyCodeLine{1010 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Types>}
\DoxyCodeLine{1011 \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} TuplePolicy< ::std::tuple<Types...> >::tuple\_size;}
\DoxyCodeLine{1012 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_STD\_TUPLE\_}}
\DoxyCodeLine{1013 }
\DoxyCodeLine{1014 \textcolor{preprocessor}{\#if GTEST\_HAS\_TR1\_TUPLE || GTEST\_HAS\_STD\_TUPLE\_}}
\DoxyCodeLine{1015 \textcolor{comment}{// This helper template allows PrintTo() for tuples and}}
\DoxyCodeLine{1016 \textcolor{comment}{// UniversalTersePrintTupleFieldsToStrings() to be defined by}}
\DoxyCodeLine{1017 \textcolor{comment}{// induction on the number of tuple fields.  The idea is that}}
\DoxyCodeLine{1018 \textcolor{comment}{// TuplePrefixPrinter<N>::PrintPrefixTo(t, os) prints the first N}}
\DoxyCodeLine{1019 \textcolor{comment}{// fields in tuple t, and can be defined in terms of}}
\DoxyCodeLine{1020 \textcolor{comment}{// TuplePrefixPrinter<N -\/ 1>.}}
\DoxyCodeLine{1021 \textcolor{comment}{//}}
\DoxyCodeLine{1022 \textcolor{comment}{// The inductive case.}}
\DoxyCodeLine{1023 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{1024 \textcolor{keyword}{struct }TuplePrefixPrinter \{}
\DoxyCodeLine{1025   \textcolor{comment}{// Prints the first N fields of a tuple.}}
\DoxyCodeLine{1026   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple>}
\DoxyCodeLine{1027   \textcolor{keyword}{static} \textcolor{keywordtype}{void} PrintPrefixTo(\textcolor{keyword}{const} Tuple\& t, ::std::ostream* os) \{}
\DoxyCodeLine{1028     TuplePrefixPrinter<N -\/ 1>::PrintPrefixTo(t, os);}
\DoxyCodeLine{1029     \mbox{\hyperlink{gtest-port_8h_a69b0cadb05bf2a1ef96151243c6b6241}{GTEST\_INTENTIONAL\_CONST\_COND\_PUSH\_}}()}
\DoxyCodeLine{1030     if (N > 1) \{}
\DoxyCodeLine{1031     \mbox{\hyperlink{gtest-port_8h_ad115e2c466f7e8a32f1cf23ef2e5f220}{GTEST\_INTENTIONAL\_CONST\_COND\_POP\_}}()}
\DoxyCodeLine{1032       *os << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{1033     \}}
\DoxyCodeLine{1034     UniversalPrinter<}
\DoxyCodeLine{1035         \textcolor{keyword}{typename} TuplePolicy<Tuple>::template tuple\_element<N -\/ 1>::type>}
\DoxyCodeLine{1036         ::Print(TuplePolicy<Tuple>::template get<N -\/ 1>(t), os);}
\DoxyCodeLine{1037   \}}
\DoxyCodeLine{1038 }
\DoxyCodeLine{1039   \textcolor{comment}{// Tersely prints the first N fields of a tuple to a string vector,}}
\DoxyCodeLine{1040   \textcolor{comment}{// one element for each field.}}
\DoxyCodeLine{1041   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple>}
\DoxyCodeLine{1042   \textcolor{keyword}{static} \textcolor{keywordtype}{void} TersePrintPrefixToStrings(\textcolor{keyword}{const} Tuple\& t, \mbox{\hyperlink{namespacetesting_1_1internal_a50003bb76ec2934be1062be11efba8bf}{Strings}}* strings) \{}
\DoxyCodeLine{1043     TuplePrefixPrinter<N -\/ 1>::TersePrintPrefixToStrings(t, strings);}
\DoxyCodeLine{1044     ::std::stringstream ss;}
\DoxyCodeLine{1045     \mbox{\hyperlink{namespacetesting_1_1internal_afa92f5a284929dc3723e654a25feb7b9}{UniversalTersePrint}}(TuplePolicy<Tuple>::template get<N -\/ 1>(t), \&ss);}
\DoxyCodeLine{1046     strings-\/>push\_back(ss.str());}
\DoxyCodeLine{1047   \}}
\DoxyCodeLine{1048 \};}
\DoxyCodeLine{1049 }
\DoxyCodeLine{1050 \textcolor{comment}{// Base case.}}
\DoxyCodeLine{1051 \textcolor{keyword}{template} <>}
\DoxyCodeLine{1052 \textcolor{keyword}{struct }TuplePrefixPrinter<0> \{}
\DoxyCodeLine{1053   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple>}
\DoxyCodeLine{1054   \textcolor{keyword}{static} \textcolor{keywordtype}{void} PrintPrefixTo(\textcolor{keyword}{const} Tuple\&, ::std::ostream*) \{\}}
\DoxyCodeLine{1055 }
\DoxyCodeLine{1056   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple>}
\DoxyCodeLine{1057   \textcolor{keyword}{static} \textcolor{keywordtype}{void} TersePrintPrefixToStrings(\textcolor{keyword}{const} Tuple\&, \mbox{\hyperlink{namespacetesting_1_1internal_a50003bb76ec2934be1062be11efba8bf}{Strings}}*) \{\}}
\DoxyCodeLine{1058 \};}
\DoxyCodeLine{1059 }
\DoxyCodeLine{1060 \textcolor{comment}{// Helper function for printing a tuple.}}
\DoxyCodeLine{1061 \textcolor{comment}{// Tuple must be either std::tr1::tuple or std::tuple type.}}
\DoxyCodeLine{1062 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple>}
\DoxyCodeLine{1063 \textcolor{keywordtype}{void} PrintTupleTo(\textcolor{keyword}{const} Tuple\& t, ::std::ostream* os) \{}
\DoxyCodeLine{1064   *os << \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{1065   TuplePrefixPrinter<TuplePolicy<Tuple>::tuple\_size>::PrintPrefixTo(t, os);}
\DoxyCodeLine{1066   *os << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{1067 \}}
\DoxyCodeLine{1068 }
\DoxyCodeLine{1069 \textcolor{comment}{// Prints the fields of a tuple tersely to a string vector, one}}
\DoxyCodeLine{1070 \textcolor{comment}{// element for each field.  See the comment before}}
\DoxyCodeLine{1071 \textcolor{comment}{// UniversalTersePrint() for how we define "{}tersely"{}.}}
\DoxyCodeLine{1072 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple>}
\DoxyCodeLine{1073 \mbox{\hyperlink{namespacetesting_1_1internal_a50003bb76ec2934be1062be11efba8bf}{Strings}} UniversalTersePrintTupleFieldsToStrings(\textcolor{keyword}{const} Tuple\& value) \{}
\DoxyCodeLine{1074   \mbox{\hyperlink{namespacetesting_1_1internal_a50003bb76ec2934be1062be11efba8bf}{Strings}} result;}
\DoxyCodeLine{1075   TuplePrefixPrinter<TuplePolicy<Tuple>::tuple\_size>::}
\DoxyCodeLine{1076       TersePrintPrefixToStrings(value, \&result);}
\DoxyCodeLine{1077   \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1078 \}}
\DoxyCodeLine{1079 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_TR1\_TUPLE || GTEST\_HAS\_STD\_TUPLE\_}}
\DoxyCodeLine{1080 }
\DoxyCodeLine{1081 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{1082 }
\DoxyCodeLine{1083 \textcolor{preprocessor}{\#if GTEST\_HAS\_ABSL}}
\DoxyCodeLine{1084 \textcolor{keyword}{namespace }internal2 \{}
\DoxyCodeLine{1085 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1086 \textcolor{keywordtype}{void} \mbox{\hyperlink{classtesting_1_1internal2_1_1_type_without_formatter_a6651f6f7be2c0f899729eeb6038f76d3}{TypeWithoutFormatter<T, kConvertibleToStringView>::PrintValue}}(}
\DoxyCodeLine{1087     \textcolor{keyword}{const} T\& value, ::std::ostream* os) \{}
\DoxyCodeLine{1088   \mbox{\hyperlink{namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460}{internal::PrintTo}}(absl::string\_view(value), os);}
\DoxyCodeLine{1089 \}}
\DoxyCodeLine{1090 \}  \textcolor{comment}{// namespace internal2}}
\DoxyCodeLine{1091 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1092 }
\DoxyCodeLine{1093 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1094 \mbox{\hyperlink{namespacetesting_1_1internal_a5ca8a348395a6145775c1a2334e21889}{::std::string}} \mbox{\hyperlink{namespacetesting_aa5717bb1144edd1d262d310ba70c82ed}{PrintToString}}(\textcolor{keyword}{const} T\& value) \{}
\DoxyCodeLine{1095   ::std::stringstream ss;}
\DoxyCodeLine{1096   \mbox{\hyperlink{classtesting_1_1internal_1_1_universal_terse_printer_a042249cdb42fdb77588c9ad54ea7ed54}{internal::UniversalTersePrinter<T>::Print}}(value, \&ss);}
\DoxyCodeLine{1097   \textcolor{keywordflow}{return} ss.str();}
\DoxyCodeLine{1098 \}}
\DoxyCodeLine{1099 }
\DoxyCodeLine{1100 \}  \textcolor{comment}{// namespace testing}}
\DoxyCodeLine{1101 }
\DoxyCodeLine{1102 \textcolor{comment}{// Include any custom printer added by the local installation.}}
\DoxyCodeLine{1103 \textcolor{comment}{// We must include this header at the end to make sure it can use the}}
\DoxyCodeLine{1104 \textcolor{comment}{// declarations from this file.}}
\DoxyCodeLine{1105 \textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{internal_2custom_2gtest-printers_8h}{gtest/internal/custom/gtest-\/printers.h}}"{}}}
\DoxyCodeLine{1106 }
\DoxyCodeLine{1107 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_INCLUDE\_GTEST\_GTEST\_PRINTERS\_H\_}}

\end{DoxyCode}
